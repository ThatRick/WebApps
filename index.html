<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Microwave Timer – Continuous Simulation</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
:root {
  --bg: #0d0d0d;
  --card: #161616;
  --text: #e8e8e8;
  --muted: #7a7a7a;
  --track: #1f1f1f;
  --fill-start: #005f99;
  --fill-end: #008644;
  --radius: 14px;
  --space: clamp(0.9rem,3vw,1.4rem);
  --mono: 'SFMono-Regular','Consolas','Liberation Mono',monospace;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
  background: var(--bg);
  color: var(--text);
  font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  padding: var(--space);
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  transition: background-color 0.2s ease-in-out; /* Smooth transition for flash */
}
header { text-align: center; margin-bottom: clamp(1.2rem,4vw,2rem); }
h1 { font-size: clamp(1.6rem,4vw,2rem); font-weight: 600; }
h1 small { display: block; font-size: .78em; color: var(--muted); }
#card {
  background: var(--card);
  padding: var(--space);
  border-radius: var(--radius);
  box-shadow: 0 6px 18px rgba(0,0,0,0.35);
  flex: 1;
  display: flex;
  flex-direction: column;
}
#controls { display: block; }
.field { margin-top: var(--space); }
label {
  display: block;
  margin-bottom: .25rem;
  font-size: 1.05rem;
  color: var(--muted);
}
input[type=range] {
  width: 100%;
  height: 6px;
  background: #444;
  border-radius: 4px;
  outline: none;
  appearance: none;
  margin: .35rem 0;
}
input[type=range]:disabled {
  opacity: 0.5;
}
input[type=range]::-webkit-slider-thumb {
  appearance: none;
  width: 22px; height: 22px;
  border-radius: 50%;
  background: var(--fill-end);
  border: none;
  cursor: pointer;
}
input[type=range]:disabled::-webkit-slider-thumb {
  cursor: not-allowed;
  background: #555;
}
.value-display {
  margin-left: .4rem;
  font-size: 1.6rem;
  font-weight: 600;
  color: var(--text);
}
details {
  margin-top: var(--space);
  border-top: 1px dashed #333;
  padding-top: var(--space);
}
summary {
  cursor: pointer;
  color: var(--fill-end);
  font-weight: 500;
}
input[type=number] {
  width: 100%;
  padding: .6rem .8rem;
  margin-top: .25rem;
  font-size: 1rem;
  border: 1px solid #333;
  border-radius: var(--radius);
  background: #000;
  color: var(--text);
}
input[type=number]:disabled {
    background: #111;
    color: #777;
    cursor: not-allowed;
}
#startBtn {
  width: 100%;
  height: 54px;
  margin-top: var(--space);
  border-radius: var(--radius);
  background: linear-gradient(90deg, var(--fill-start), var(--fill-end));
  border: none;
  color: #000;
  font-size: 1.25rem;
  font-weight: 600;
  cursor: pointer;
}
#progressWrap {
  width: 100%;
  height: 54px;
  margin-top: var(--space);
  border-radius: var(--radius);
  background: var(--track);
  overflow: hidden;
  position: relative;
  display: none; /* Initially hidden */
  cursor: pointer; /* Indicate interactivity */
}
#progressBar {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, var(--fill-start), var(--fill-end));
  transition: width 0.15s linear; /* Smooth progress */
}
#barLabel {
  position: absolute;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  font-family: var(--mono);
  font-size: 1.4rem;
  color: #fff;
  text-shadow: 0 0 4px rgba(0,0,0,0.6);
  pointer-events: none; /* Allow clicks on wrapper */
}
#status {
  margin-top: var(--space);
  text-align: center;
  font-family: var(--mono);
  font-size: 1rem;
  color: var(--muted);
  min-height: 1.2em; /* Prevent layout shifts */
}
#info {
  margin-top: var(--space);
  text-align: center;
  font-family: var(--mono);
  font-size: 2.4rem;
  min-height: 1.2em; /* Prevent layout shifts */
}
footer {
  margin-top: var(--space);
  text-align: center;
  font-size: 0.85rem;
  color: var(--muted);
  font-style: italic;
}

/* Style for flashing background */
body.flash-green {
  background-color: var(--fill-end); /* Use one of the fill colors */
}
</style>
</head>
<body>
<header>
  <h1>Microwave Timer<small>Continuous Simulation</small></h1>
</header>
<div id="card">
  <div id="controls"> <!-- This div will remain visible -->
    <div class="field">
      <label>Start <span id="startVal" class="value-display">13 °C</span></label>
      <input id="startTemp" type="range" min="5" max="20" step="0.1" value="13">
    </div>
    <div class="field">
      <label>Target <span id="targetVal" class="value-display">80 °C</span></label>
      <input id="targetTemp" type="range" min="75" max="90" step="1" value="80">
    </div>
    <details>
      <summary>Advanced</summary>
      <label>Water mass (g)<input id="waterMass" type="number" value="303" step="1"></label>
      <label>Mug mass (g)<input id="mugMass" type="number" value="250" step="1"></label>
      <label>P₀ (W)<input id="power0" type="number" value="600" step="10"></label>
      <label>hA (W / °C)<input id="heatLoss" type="number" value="1.1" step="0.1"></label>
      <label>Room T (°C)<input id="roomTemp" type="number" value="22" step="0.1"></label>
    </details>
  </div>
  <button id="startBtn" type="button">START</button>
  <div id="progressWrap"><div id="progressBar"></div><span id="barLabel"></span></div>
  <div id="status"></div> <!-- Status text will be simpler -->
  <div id="info"></div>
</div>
<footer>tap anywhere (except progress bar/controls) to stop flashing & simulation updates</footer>

<script>
// --- START OF REFACTORED SCRIPT SECTION ---

// persistence
const KEY="microwaveTimerSettings";
function saveSettings(){
  if (state === "idle") {
    localStorage.setItem(KEY, JSON.stringify({
      start:+startTemp.value,target:+targetTemp.value,
      water:+waterMass.value,mug:+mugMass.value,
      P0:+power0.value,hA:+heatLoss.value,room:+roomTemp.value
    }));
  }
}
function loadSettings(){
  try{
    const d=JSON.parse(localStorage.getItem(KEY)||"{}");
    if(d.start) startTemp.value=d.start;
    if(d.target) targetTemp.value=d.target;
    if(d.water) waterMass.value=d.water;
    if(d.mug) mugMass.value=d.mug;
    if(d.P0) power0.value=d.P0;
    if(d.hA) heatLoss.value=d.hA;
    if(d.room) roomTemp.value=d.room;
  }catch(e){ console.error("Error loading settings:", e); }
}

// helpers
const $=id=>document.getElementById(id);
function fmtTime(s){
  s=Math.max(0,Math.round(s));const m=Math.floor(s/60),sec=s%60;
  return m? m+":"+sec.toString().padStart(2,"0") : sec.toString();
}

// model (no changes needed)
const cW=4186, cC=880;
function getParams(){
  const T0=+startTemp.value, Tt=+targetTemp.value,
        mW=+waterMass.value/1000, mM=+mugMass.value/1000,
        P0=+power0.value, hA=+heatLoss.value, Ta=+roomTemp.value;
  return {T0,Tt,P0,hA,Ta,MC:mW*cW + mM*cC};
}
function predictTime(p){
  if(p.Tt<=p.T0) return null;
  const equilibriumTempRise = p.P0 / p.hA;
  const maxReachableTemp = p.Ta + equilibriumTempRise;
  if (p.P0 <= 0 || p.hA <= 0) {
      if (p.P0 > 0 && p.hA <= 0) return Infinity;
      if (p.P0 <= 0 && p.hA > 0 && p.Tt > p.T0) return Infinity;
      if (p.P0 <= 0 && p.hA <= 0 && p.Tt > p.T0) return Infinity;
      if (p.Tt <= p.T0) return null;
  }
  if (p.Tt > maxReachableTemp) return Infinity;
  const numerator = p.P0 - p.hA * (p.T0 - p.Ta);
  const denominator = p.P0 - p.hA * (p.Tt - p.Ta);
  if (numerator <= 0 || denominator <= 0) return Infinity;
  return (p.MC/p.hA) * Math.log(numerator / denominator);
}
function calculateTemp(p, elapsed, startTemp) {
  const T0_eff = startTemp !== undefined ? startTemp : p.T0;
  if (p.P0 <= 0) { return calculateCoolingTemp(p, elapsed, T0_eff); }
  if (p.hA <= 0) { return T0_eff + (p.P0 / p.MC) * elapsed; }
  const equilibriumTempRise = p.P0 / p.hA;
  return p.Ta + equilibriumTempRise - (equilibriumTempRise - (T0_eff - p.Ta)) * Math.exp(-p.hA * elapsed / p.MC);
}
function calculateCoolingTemp(p, elapsed, startTemp) {
    if (p.hA <= 0) return startTemp;
    return p.Ta + (startTemp - p.Ta) * Math.exp(-p.hA * elapsed / p.MC);
}

// --- State Management ---
let state = "idle"; // "idle", "heating", "paused", "finished"
let simulationInterval = null; // Single interval for heating/cooling simulation steps
let flashInterval = null;
let sim = {
    params: null,           // Parameters used for the current run
    totalDuration: 0,       // Original total calculated heating duration
    heatingStartTime: 0,    // Timestamp when the current heating segment began
    coolingStartTime: 0,    // Timestamp when the current cooling segment began
    resumeTimeOffset: 0,    // Total time already spent heating before the current segment
    currentTemperature: 0,  // The latest calculated temperature
    pausedProgress: 0       // Progress percentage when paused
};

// UI Update Functions
function updateUIForState() {
    const isIdle = state === "idle";
    const isRunning = state === "heating" || state === "paused" || state === "finished";

    $('startBtn').style.display = isIdle ? 'block' : 'none';
    $('progressWrap').style.display = isRunning ? 'block' : 'none';

    // Disable/Enable controls
    [startTemp, targetTemp, waterMass, mugMass, power0, heatLoss, roomTemp].forEach(el => {
        el.disabled = !isIdle;
    });

    // Set status text
    switch (state) {
        case "idle":
            $('status').textContent = "";
            updateControlsDisplay(); // Update temp displays from inputs
            break;
        case "heating":
            $('status').textContent = "Heating";
            break;
        case "paused":
            $('status').textContent = "Paused";
            break;
        case "finished":
            $('status').textContent = "Finished!";
            break;
    }

    // Ensure flashing is stopped if not finished
    if (state !== "finished") {
        stopFlash();
    }
}

function updateControlsDisplay() {
    // Update the displayed °C values next to the sliders/inputs
    $('startVal').textContent = startTemp.value + " °C";
    $('targetVal').textContent = targetTemp.value + " °C";
}

function updatePredictedTime() {
    // Update the large time display at the bottom
    const p = getParams();
    const t = predictTime(p);
    $('info').textContent = t === null ? "Start ≥ Target" : isFinite(t) ? fmtTime(t) + " s" : "∞";
}

function updateSimulationDisplay(temp, remainingHeatingTime = null) {
    sim.currentTemperature = temp; // Store latest temperature
    $('barLabel').textContent = temp.toFixed(1) + "°";

    if (state === 'heating' && remainingHeatingTime !== null) {
        const progress = Math.min(100, ((sim.totalDuration - remainingHeatingTime) / sim.totalDuration) * 100);
        $('progressBar').style.width = progress + '%';
        $('info').textContent = fmtTime(remainingHeatingTime) + " s";
        sim.pausedProgress = progress; // Store progress for potential pause
    } else if (state === 'paused') {
        // Keep progress bar frozen, info shows '--' or similar
        $('progressBar').style.width = sim.pausedProgress + '%';
        $('info').textContent = "--";
    } else if (state === 'finished') {
        // Keep progress bar full, info shows 0s
        $('progressBar').style.width = '100%';
        $('info').textContent = "0 s";
    }
    // If idle, info shows predicted time (handled by updatePredictedTime)
}


// --- Simulation Step Functions ---
function heatingStep() {
    const now = Date.now();
    const elapsedSinceSegmentStart = (now - sim.heatingStartTime) / 1000;
    const totalElapsedHeatingTime = sim.resumeTimeOffset + elapsedSinceSegmentStart;

    if (totalElapsedHeatingTime >= sim.totalDuration) {
        // --- FINISHED ---
        const finalTemp = sim.params.Tt;
        sim.currentTemperature = finalTemp; // Ensure final temp is target
        sim.pausedProgress = 100;
        updateSimulationDisplay(finalTemp, 0); // Update UI to final state
        setState("finished"); // Transition state
    } else {
        // --- STILL HEATING ---
        const currentTemp = calculateTemp(sim.params, totalElapsedHeatingTime, sim.params.T0);
        const remainingTime = sim.totalDuration - totalElapsedHeatingTime;
        updateSimulationDisplay(currentTemp, remainingTime);
    }
}

function coolingStep() {
    const now = Date.now();
    const elapsedCoolingTime = (now - sim.coolingStartTime) / 1000;
    // Cooling starts from the temperature recorded when pause/finish occurred
    const coolingStartTemp = sim.currentTemperature;
    const currentTemp = calculateCoolingTemp(sim.params, elapsedCoolingTime, coolingStartTemp);
    // Only update temperature label, progress/time remain as per state (paused/finished)
    updateSimulationDisplay(currentTemp);
}


// --- State Transition Logic ---
function setState(newState) {
    if (state === newState) return; // No change
    const previousState = state;
    state = newState;

    console.log(`State transition: ${previousState} -> ${newState}`); // Debugging

    // Stop previous simulation interval ONLY if entering idle
    if (newState === 'idle') {
        stopSimulation();
    }

    // Update UI elements based on the new state
    updateUIForState();

    // Start/Manage Simulation Interval and Flash based on new state
    switch (newState) {
        case "heating":
            sim.heatingStartTime = Date.now(); // Set start time for this heating segment
            if (!simulationInterval) { // Start simulation if not already running
               startSimulation(heatingStep);
            }
            break;
        case "paused":
            sim.coolingStartTime = Date.now(); // Record when cooling starts
            // The simulation interval continues running, but we'll change the step function
            if (!simulationInterval) { // Should ideally be running, but safety check
                startSimulation(coolingStep);
            }
            break;
        case "finished":
            sim.coolingStartTime = Date.now(); // Record when cooling starts post-finish
            playChime();
            beginFlash();
            // Simulation interval continues running, ensure it calls coolingStep
             if (!simulationInterval) { // Should ideally be running, but safety check
                startSimulation(coolingStep);
            }
            break;
        case "idle":
            // Simulation stopped by the check at the beginning of setState
            updatePredictedTime(); // Update prediction based on current controls
            break;
    }
}

// --- Simulation Control ---
function startSimulation(stepFunction) {
    if (simulationInterval) return; // Already running
    console.log("Starting simulation interval");
    simulationInterval = setInterval(() => {
        // Dynamically choose which step function to run based on current state
        if (state === 'heating') {
            heatingStep();
        } else if (state === 'paused' || state === 'finished') {
            coolingStep();
        } else {
            // Should not happen if interval is managed correctly, but stop if idle
            stopSimulation();
        }
    }, 250); // Update simulation 4 times per second
}

function stopSimulation() {
    if (simulationInterval) {
        console.log("Stopping simulation interval");
        clearInterval(simulationInterval);
        simulationInterval = null;
    }
    stopFlash(); // Also stop flash if simulation stops
}

// --- Actions ---
function startHeatingAction() {
    // Use values currently in the inputs to calculate parameters and duration
    sim.params = getParams();
    sim.totalDuration = predictTime(sim.params);

    if (sim.totalDuration === null || !isFinite(sim.totalDuration)) {
        updatePredictedTime(); // Show ∞ or error message
        return;
    }

    // Initialize simulation state variables
    sim.resumeTimeOffset = 0;
    sim.currentTemperature = sim.params.T0; // Start at initial temp
    sim.pausedProgress = 0;

    updateSimulationDisplay(sim.currentTemperature, sim.totalDuration); // Initial display before first step
    setState("heating"); // Transition state, which will start the simulation interval
}

function pauseHeatingAction() {
    if (state !== "heating") return;

    // Stop the heating timer part, calculate offset
    const now = Date.now();
    const elapsedSinceSegmentStart = (now - sim.heatingStartTime) / 1000;
    sim.resumeTimeOffset += elapsedSinceSegmentStart;

    // Temperature (sim.currentTemperature) and progress (sim.pausedProgress)
    // are already updated by the last heatingStep.

    setState("paused"); // Transition state, simulation interval will now call coolingStep
}

function resumeHeatingAction() {
    if (state !== "paused") return;
    // No need to stop interval, just change state back to heating
    setState("heating"); // Transition state, interval will call heatingStep again
                         // heatingStartTime will be set by setState("heating")
}

// --- Audio & Visual Feedback ---
let audioCtx = null;
function playChime(){ /* ... same as before ... */ }

function beginFlash(){
  if (flashInterval) return; // Already flashing
  let on = false;
  flashInterval = setInterval(() => {
    on = !on;
    document.body.classList.toggle('flash-green', on);
  }, 500);
}

function stopFlash(){
    if (flashInterval) {
        clearInterval(flashInterval);
        flashInterval = null;
        document.body.classList.remove('flash-green');
    }
}

// --- Event Binding ---
$('startBtn').addEventListener('click', startHeatingAction);

$('progressWrap').addEventListener('click', () => {
  // Only allow pause/resume toggle, do nothing if finished
  if (state === "heating") {
    pauseHeatingAction();
  } else if (state === "paused") {
    resumeHeatingAction();
  }
});

// Click anywhere else stops flashing AND the simulation updates
document.body.addEventListener('click', (e) => {
    const isProgressClick = e.target === $('progressWrap') || $('progressWrap').contains(e.target);
    const isControlClick = e.target.closest('#controls') || e.target === $('startBtn');

    // If click is outside interactive elements AND simulation is running
    if (!isProgressClick && !isControlClick && state !== 'idle') {
       console.log("Body click detected - stopping simulation and flash");
       stopSimulation(); // Stops interval AND flash
       // Optional: Reset state to idle? Or leave it showing the last state?
       // setState('idle'); // Uncomment to fully reset on outside click
    }
});

// Update predicted time display whenever controls change (only possible in idle state)
[startTemp, targetTemp, waterMass, mugMass, power0, heatLoss, roomTemp].forEach(el => {
  el.addEventListener('input', () => {
      if (state === 'idle') {
          updateControlsDisplay();
          updatePredictedTime();
      }
  });
  el.addEventListener('change', () => {
       if (state === 'idle') {
           saveSettings(); // Save on 'change' (e.g., after number input)
       }
  });
});

// --- Initialization ---
loadSettings();
updateControlsDisplay(); // Show initial values from inputs
updatePredictedTime();  // Show initial prediction
setState("idle"); // Set initial state and update UI accordingly

window.addEventListener('beforeunload', () => {
    stopSimulation(); // Clean up interval on unload
});

// --- END OF REFACTORED SCRIPT SECTION ---
</script>
</body>
</html>