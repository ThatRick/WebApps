<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Microwave Timer - Simulation Centric</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
:root {
  --bg: #0d0d0d; --card: #161616; --text: #e8e8e8; --muted: #7a7a7a;
  --track: #1f1f1f; --fill-start: #005f99; --fill-end: #008644;
  --radius: 14px; --space: clamp(0.9rem,3vw,1.4rem);
  --mono: 'SFMono-Regular','Consolas','Liberation Mono',monospace;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
  background: var(--bg); color: var(--text);
  font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  padding: var(--space); display: flex; flex-direction: column; min-height: 100vh;
  transition: background-color 0.2s ease-in-out;
}
header { text-align: center; margin-bottom: clamp(1.2rem,4vw,2rem); }
h1 { font-size: clamp(1.6rem,4vw,2rem); font-weight: 600; }
h1 small { display: block; font-size: .78em; color: var(--muted); }
#card {
  background: var(--card); padding: var(--space); border-radius: var(--radius);
  box-shadow: 0 6px 18px rgba(0,0,0,0.35); flex: 1; display: flex; flex-direction: column;
}
#controls { display: block; }
.field { margin-top: var(--space); }
label { display: block; margin-bottom: .25rem; font-size: 1.05rem; color: var(--muted); }
input[type=range] {
  width: 100%; height: 6px; background: #444; border-radius: 4px; outline: none;
  appearance: none; margin: .35rem 0;
}
input[type=range]:disabled { opacity: 0.5; }
input[type=range]::-webkit-slider-thumb {
  appearance: none; width: 22px; height: 22px; border-radius: 50%;
  background: var(--fill-end); border: none; cursor: pointer;
}
input[type=range]:disabled::-webkit-slider-thumb { cursor: not-allowed; background: #555; }
.value-display { margin-left: .4rem; font-size: 1.6rem; font-weight: 600; color: var(--text); }
details { margin-top: var(--space); border-top: 1px dashed #333; padding-top: var(--space); }
summary { cursor: pointer; color: var(--fill-end); font-weight: 500; }
input[type=number] {
  width: 100%; padding: .6rem .8rem; margin-top: .25rem; font-size: 1rem;
  border: 1px solid #333; border-radius: var(--radius); background: #000; color: var(--text);
}
input[type=number]:disabled { background: #111; color: #777; cursor: not-allowed; }
#startBtn {
  width: 100%; height: 54px; margin-top: var(--space); border-radius: var(--radius);
  background: linear-gradient(90deg, var(--fill-start), var(--fill-end));
  border: none; color: #000; font-size: 1.25rem; font-weight: 600; cursor: pointer;
}
#progressWrap {
  width: 100%; height: 54px; margin-top: var(--space); border-radius: var(--radius);
  background: var(--track); overflow: hidden; position: relative; display: none; cursor: pointer;
}
#progressBar {
  height: 100%; width: 0%;
  background: linear-gradient(90deg, var(--fill-start), var(--fill-end));
  transition: width 0.2s linear; /* Slightly slower for smoother look based on temp */
}
#barLabel {
  position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
  font-family: var(--mono); font-size: 1.4rem; color: #fff;
  text-shadow: 0 0 4px rgba(0,0,0,0.6); pointer-events: none;
}
#status {
  margin-top: var(--space); text-align: center; font-family: var(--mono);
  font-size: 1rem; color: var(--muted); min-height: 1.2em;
}
#info { /* Now displays estimated remaining time */
  margin-top: var(--space); text-align: center; font-family: var(--mono);
  font-size: 2.4rem; min-height: 1.2em;
}
footer {
  margin-top: var(--space); text-align: center; font-size: 0.85rem;
  color: var(--muted); font-style: italic;
}
body.flash-green { background-color: var(--fill-end); }
</style>
</head>
<body>
<header>
  <h1>Microwave Timer<small>Simulation Centric</small></h1>
</header>
<div id="card">
  <div id="controls">
    <div class="field">
      <label>Start <span id="startVal" class="value-display">13 °C</span></label>
      <input id="startTemp" type="range" min="5" max="20" step="0.1" value="13">
    </div>
    <div class="field">
      <label>Target <span id="targetVal" class="value-display">80 °C</span></label>
      <input id="targetTemp" type="range" min="75" max="90" step="1" value="80">
    </div>
    <details>
      <summary>Advanced</summary>
      <label>Water mass (g)<input id="waterMass" type="number" value="303" step="1"></label>
      <label>Mug mass (g)<input id="mugMass" type="number" value="250" step="1"></label>
      <label>P₀ (W)<input id="power0" type="number" value="600" step="10"></label>
      <label>hA (W / °C)<input id="heatLoss" type="number" value="1.1" step="0.1"></label>
      <label>Room T (°C)<input id="roomTemp" type="number" value="22" step="0.1"></label>
    </details>
  </div>
  <button id="startBtn" type="button">START</button>
  <div id="progressWrap"><div id="progressBar"></div><span id="barLabel"></span></div>
  <div id="status"></div>
  <div id="info"></div> <!-- Will show dynamic estimated time -->
</div>
<footer>tap anywhere (except progress bar/controls) to stop simulation & flashing</footer>

<script>
// --- Constants & Persistence ---
const KEY = "microwaveTimerSettings_sim";
const SIMULATION_INTERVAL_MS = 250; // How often to run simulation step (ms)
const cW = 4186, cC = 880; // J/(kg*C)

function saveSettings() { /* ... same as before ... */ }
function loadSettings() { /* ... same as before ... */ }

// --- Helpers ---
const $ = id => document.getElementById(id);
function fmtTime(s) { /* ... same as before ... */ }

// --- Physics Model ---
function getParams() {
    const T0 = +startTemp.value, Tt = +targetTemp.value,
          mW = +waterMass.value / 1000, mM = +mugMass.value / 1000,
          P0 = +power0.value, hA = +heatLoss.value, Ta = +roomTemp.value;
    return { T0, Tt, P0, hA, Ta, MC: mW * cW + mM * cC };
}

/** Calculates the temperature change over a small deltaTime */
function calculateDeltaT(params, currentTemp, deltaTime, isHeating) {
    if (params.MC <= 0) return 0; // Prevent division by zero

    const powerInput = isHeating ? params.P0 : 0;
    const powerLoss = params.hA > 0 ? params.hA * (currentTemp - params.Ta) : 0;
    const netPower = powerInput - powerLoss;

    const dT_dt = netPower / params.MC; // Rate of temperature change (°C / s)
    return dT_dt * deltaTime; // Temperature change over deltaTime (°C)
}

/** Estimates remaining time to reach target from current temp */
function estimateRemainingTime(params, currentTemp) {
    const targetTemp = params.Tt;
    if (currentTemp >= targetTemp) return 0; // Already there or past it
    if (params.P0 <= 0) return Infinity; // No power, can't heat further

    const equilibriumTempRise = params.hA > 0 ? params.P0 / params.hA : Infinity;
    const maxReachableTemp = params.Ta + equilibriumTempRise;

    if (targetTemp > maxReachableTemp) return Infinity; // Target is unreachable

    // Use the same formula as predictTime, but starting from currentTemp
    const numerator = params.P0 - params.hA * (currentTemp - params.Ta);
    const denominator = params.P0 - params.hA * (targetTemp - params.Ta);

    // Ensure log arguments are valid (should be caught by maxReachableTemp check mostly)
    if (numerator <= 0 || denominator <= 0) {
        // If numerator <= 0, current temp might be at/above equilibrium for heating.
        // If denominator <= 0, target temp is at/above equilibrium.
        return (currentTemp < targetTemp) ? Infinity : 0;
    }
    if (params.hA <= 0) { // No heat loss, linear heating
        if (params.P0 <= 0) return Infinity;
        return (params.MC * (targetTemp - currentTemp)) / params.P0;
    }

    return (params.MC / params.hA) * Math.log(numerator / denominator);
}

// --- State Management ---
let state = "idle"; // "idle", "heating", "paused", "finished"
let simulationInterval = null;
let flashInterval = null;
let sim = {
    params: null,           // Parameters for the current run
    currentTemperature: 0,  // The single source of truth for temperature
    initialTemperature: 0, // T0 at the moment START was pressed (for progress bar)
    targetTemperature: 0,  // Tt at the moment START was pressed (for progress bar & finish check)
    lastTickTime: 0         // Timestamp of the last simulation step
};

// --- UI Update Functions ---
function updateUI() {
    if (state === 'idle') {
        updatePredictedTimeFromInputs(); // Show prediction based on controls
        $('progressWrap').style.display = 'none';
        $('barLabel').textContent = ''; // Clear temp display
        return;
    }

    // Update temperature display
    $('barLabel').textContent = sim.currentTemperature.toFixed(1) + "°";

    // Update progress bar (relative to initial start and target)
    const tempRange = sim.targetTemperature - sim.initialTemperature;
    let progress = 0;
    if (tempRange > 0) {
        progress = ((sim.currentTemperature - sim.initialTemperature) / tempRange) * 100;
    } else if (sim.currentTemperature >= sim.targetTemperature) {
        progress = 100; // Handle edge case where start >= target initially
    }
    progress = Math.max(0, Math.min(100, progress)); // Clamp 0-100
    $('progressBar').style.width = progress + '%';

    // Update estimated remaining time display
    if (state === 'heating' || state === 'paused') {
        const remaining = estimateRemainingTime(sim.params, sim.currentTemperature);
        $('info').textContent = isFinite(remaining) ? fmtTime(remaining) + " s" : "∞";
    } else if (state === 'finished') {
        $('info').textContent = "0 s";
    }
}

function updateControlsOnIdle() {
    // Update the displayed °C values next to the sliders/inputs
    $('startVal').textContent = startTemp.value + " °C";
    $('targetVal').textContent = targetTemp.value + " °C";
    updatePredictedTimeFromInputs();
}

function updatePredictedTimeFromInputs() {
    // Used only when idle to show prediction based on control values
    const p = getParams(); // Get current params from inputs
    const t = estimateRemainingTime(p, p.T0); // Estimate time from T0 set in inputs
    $('info').textContent = t === null || t === 0 ? "Start ≥ Target" : isFinite(t) ? fmtTime(t) + " s" : "∞";
}

function updateUIForStateChange() {
    const isIdle = state === "idle";
    const isRunning = !isIdle;

    $('startBtn').style.display = isIdle ? 'block' : 'none';
    $('progressWrap').style.display = isRunning ? 'block' : 'none';

    // Disable/Enable controls
    [startTemp, targetTemp, waterMass, mugMass, power0, heatLoss, roomTemp].forEach(el => {
        el.disabled = isRunning;
    });

    // Set status text
    switch (state) {
        case "idle": $('status').textContent = ""; break;
        case "heating": $('status').textContent = "Heating"; break;
        case "paused": $('status').textContent = "Paused"; break;
        case "finished": $('status').textContent = "Finished!"; break;
    }

    // Ensure flashing is stopped if not finished
    if (state !== "finished") {
        stopFlash();
    }
}


// --- Simulation Loop ---
function simulationStep() {
    if (state === 'idle' || !sim.params) return; // Should not happen if interval is managed

    const now = Date.now();
    const deltaTime = (now - sim.lastTickTime) / 1000; // Time since last step in seconds
    sim.lastTickTime = now;

    if (deltaTime <= 0) return; // Avoid issues if timer resolution is low or paused

    const isHeating = (state === 'heating');
    const deltaT = calculateDeltaT(sim.params, sim.currentTemperature, deltaTime, isHeating);
    sim.currentTemperature += deltaT;

    // Clamp temperature to avoid unrealistic values (e.g., below absolute zero if cooling is aggressive)
    // Or maybe clamp to room temp when cooling? For now, just basic physics.
     // sim.currentTemperature = Math.max(-273.15, sim.currentTemperature);
     if (!isHeating && sim.params.hA > 0 && sim.currentTemperature < sim.params.Ta) {
         sim.currentTemperature = sim.params.Ta; // Don't cool below ambient
     }


    // Check for reaching target ONLY when heating
    if (isHeating && sim.currentTemperature >= sim.targetTemperature) {
        sim.currentTemperature = sim.targetTemperature; // Snap to target
        setState("finished");
    }

    // Update all relevant UI elements based on the new temperature
    updateUI();
}

// --- State Transition Logic ---
function setState(newState) {
    if (state === newState) return;
    const previousState = state;
    state = newState;
    console.log(`State transition: ${previousState} -> ${newState}`);

    updateUIForStateChange(); // Update visibility, status text, disabled controls

    if (newState === 'idle') {
        stopSimulation(); // Stop interval and flash
        updateControlsOnIdle(); // Update display from inputs
    } else {
        // Start simulation if transitioning from idle
        if (previousState === 'idle') {
            startSimulation();
        }
        // Handle flashing on finish
        if (newState === 'finished') {
            playChime();
            beginFlash();
        }
    }
    // Update UI immediately after state change (esp. for 'finished' state time/progress)
    updateUI();
}

// --- Simulation Control ---
function startSimulation() {
    if (simulationInterval) return;
    console.log("Starting simulation interval");
    // Ensure lastTickTime is set before the first interval runs
    sim.lastTickTime = Date.now();
    simulationInterval = setInterval(simulationStep, SIMULATION_INTERVAL_MS);
}

function stopSimulation() {
    if (simulationInterval) {
        console.log("Stopping simulation interval");
        clearInterval(simulationInterval);
        simulationInterval = null;
    }
    stopFlash();
}

// --- Actions ---
function startAction() {
    if (state !== 'idle') return;

    sim.params = getParams(); // Capture parameters at start
    sim.initialTemperature = sim.params.T0; // Store initial temp for progress bar
    sim.targetTemperature = sim.params.Tt;   // Store target temp for progress bar and finish check
    sim.currentTemperature = sim.params.T0; // Initialize current temp

    // Basic check if target is reachable (using initial estimate)
    const initialEstimate = estimateRemainingTime(sim.params, sim.currentTemperature);
    if (!isFinite(initialEstimate) || initialEstimate === null) {
         $('info').textContent = initialEstimate === null ? "Start ≥ Target" : "∞ (Unreachable)";
         return; // Don't start if impossible from the get-go
    }

    setState("heating"); // This will trigger startSimulation() via state change logic
}

function pauseAction() {
    if (state === 'heating') {
        setState('paused');
    }
}

function resumeAction() {
    if (state === 'paused') {
        // When resuming, we need to reset the lastTickTime to prevent a large deltaTime jump
        sim.lastTickTime = Date.now();
        setState('heating');
    }
}

function stopAction() {
    if (state !== 'idle') {
        setState('idle'); // This stops simulation and flash
    }
}

// --- Audio & Visual Feedback --- (no changes needed)
let audioCtx = null;
function playChime(){ /* ... same as before ... */ }
function beginFlash(){ /* ... same as before ... */ }
function stopFlash(){ /* ... same as before ... */ }

// --- Event Binding ---
$('startBtn').addEventListener('click', startAction);

$('progressWrap').addEventListener('click', () => {
    if (state === 'heating') {
        pauseAction();
    } else if (state === 'paused') {
        resumeAction();
    }
    // Click does nothing if finished
});

document.body.addEventListener('click', (e) => {
    const isProgressClick = e.target === $('progressWrap') || $('progressWrap').contains(e.target);
    const isControlClick = e.target.closest('#controls') || e.target === $('startBtn');

    if (!isProgressClick && !isControlClick && state !== 'idle') {
       stopAction();
    }
});

// Update displayed values and prediction when idle controls change
[startTemp, targetTemp, waterMass, mugMass, power0, heatLoss, roomTemp].forEach(el => {
  el.addEventListener('input', () => {
      if (state === 'idle') {
          updateControlsOnIdle();
      }
  });
  el.addEventListener('change', () => {
       if (state === 'idle') {
           saveSettings(); // Save on 'change'
           updateControlsOnIdle(); // Ensure prediction updates after manual number entry + blur
       }
  });
});

// --- Initialization ---
loadSettings();
updateControlsOnIdle(); // Show initial values and prediction
setState("idle"); // Set initial state (redundant but safe)

window.addEventListener('beforeunload', () => { stopSimulation(); });

</script>
</body>
</html>