<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Microwave Timer - Simulation Centric (vFinal)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
:root {
  --bg: #0d0d0d; --card: #161616; --text: #e8e8e8; --muted: #7a7a7a;
  --track: #1f1f1f; --fill-start: #005f99; --fill-end: #008644; /* Green for flash */
  --radius: 14px; --space: clamp(0.9rem,3vw,1.4rem);
  --mono: 'SFMono-Regular','Consolas','Liberation Mono',monospace;
  --debug-bg: #222; --debug-text: #ccc; --debug-error: #ff8a8a; --debug-warn: #ffd58a;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
  background: var(--bg); color: var(--text);
  font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  padding: var(--space); display: flex; flex-direction: column; min-height: 100vh;
  transition: background-color 0.2s ease-in-out; /* Default transition */
}
header { text-align: center; margin-bottom: clamp(1.2rem,4vw,2rem); }
h1 { font-size: clamp(1.6rem,4vw,2rem); font-weight: 600; }
h1 small { display: block; font-size: .78em; color: var(--muted); }
#card {
  background: var(--card); padding: var(--space); border-radius: var(--radius);
  box-shadow: 0 6px 18px rgba(0,0,0,0.35); flex: 1; display: flex; flex-direction: column;
}
#controls { display: block; }
.field { margin-top: var(--space); }
label { display: block; margin-bottom: .25rem; font-size: 1.05rem; color: var(--muted); }
input[type=range] {
  width: 100%; height: 6px; background: #444; border-radius: 4px; outline: none;
  appearance: none; margin: .35rem 0;
}
input[type=range]:disabled { opacity: 0.5; }
input[type=range]::-webkit-slider-thumb {
  appearance: none; width: 22px; height: 22px; border-radius: 50%;
  background: var(--fill-end); border: none; cursor: pointer;
}
input[type=range]:disabled::-webkit-slider-thumb { cursor: not-allowed; background: #555; }
.value-display { margin-left: .4rem; font-size: 1.6rem; font-weight: 600; color: var(--text); }
details { margin-top: var(--space); border-top: 1px dashed #333; padding-top: var(--space); }
summary { cursor: pointer; color: var(--fill-end); font-weight: 500; }
input[type=number] {
  width: 100%; padding: .6rem .8rem; margin-top: .25rem; font-size: 1rem;
  border: 1px solid #333; border-radius: var(--radius); background: #000; color: var(--text);
}
input[type=number]:disabled { background: #111; color: #777; cursor: not-allowed; }
#startBtn {
  width: 100%; height: 54px; margin-top: var(--space); border-radius: var(--radius);
  background: linear-gradient(90deg, var(--fill-start), var(--fill-end));
  border: none; color: #000; font-size: 1.25rem; font-weight: 600; cursor: pointer;
}
#progressWrap {
  width: 100%; height: 54px; margin-top: var(--space); border-radius: var(--radius);
  background: var(--track); overflow: hidden; position: relative; display: none; cursor: pointer;
}
#progressBar {
  height: 100%; width: 0%;
  background: linear-gradient(90deg, var(--fill-start), var(--fill-end));
  transition: width 0.2s linear;
}
#barLabel {
  position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
  font-family: var(--mono); font-size: 1.4rem; color: #fff;
  text-shadow: 0 0 4px rgba(0,0,0,0.6); pointer-events: none;
}
#status {
  margin-top: var(--space); text-align: center; font-family: var(--mono);
  font-size: 1rem; color: var(--muted); min-height: 1.2em;
}
#info { /* Now displays estimated remaining time */
  margin-top: var(--space); text-align: center; font-family: var(--mono);
  font-size: 2.4rem; min-height: 1.2em;
}
footer {
  margin-top: var(--space); text-align: center; font-size: 0.85rem;
  color: var(--muted); font-style: italic;
}
body.flash-green {
   background-color: var(--fill-end) !important; /* Use !important to help override inline styles if needed */
   /* Transition is handled by the body default, or removed in JS if desired */
}

/* --- Debug Styles --- */
#debugContainer {
  margin-top: var(--space);
  border: 1px solid #444;
  border-radius: calc(var(--radius) / 2);
  background-color: var(--debug-bg);
  padding: calc(var(--space) / 2);
}
#debugHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: calc(var(--space) / 3);
}
#debugHeader span {
  font-size: 0.9rem;
  color: var(--muted);
}
#clearDebug, #toggleDebug {
  padding: 0.3rem 0.7rem;
  font-size: 0.8rem;
  background-color: #333;
  color: var(--text);
  border: none;
  border-radius: 4px;
  cursor: pointer;
}
#toggleDebug { /* Positioned after footer */
    display: block;
    margin: calc(var(--space) / 2) auto 0 auto; /* Center it below footer */
}
#debugOutput {
  max-height: 150px; /* Limit height */
  overflow-y: auto; /* Enable scroll */
  font-family: var(--mono);
  font-size: 0.8rem;
  color: var(--debug-text);
  line-height: 1.4;
}
#debugOutput > div { /* Style individual log messages */
  padding: 2px 4px;
  border-bottom: 1px dotted #383838;
  white-space: pre-wrap; /* Wrap long lines */
  word-break: break-all; /* Break long words/strings */
}
#debugOutput > div:last-child {
  border-bottom: none;
}
.debug-log { color: var(--debug-text); }
.debug-warn { color: var(--debug-warn); font-weight: bold; }
.debug-error { color: var(--debug-error); font-weight: bold; }

</style>
</head>
<body>
<header>
  <h1>Microwave Timer<small>Simulation Centric (vFinal)</small></h1>
</header>
<div id="card">
  <div id="controls">
     <!-- Inputs -->
     <div class="field">
      <label>Start <span id="startVal" class="value-display">? °C</span></label>
      <input id="startTemp" type="range" min="5" max="20" step="0.1" value="13">
    </div>
    <div class="field">
      <label>Target <span id="targetVal" class="value-display">? °C</span></label>
      <input id="targetTemp" type="range" min="75" max="90" step="1" value="80">
    </div>
    <details>
      <summary>Advanced</summary>
      <label>Water mass (g)<input id="waterMass" type="number" placeholder="e.g., 300" value="303" step="1" min="1"></label>
      <label>Mug mass (g)<input id="mugMass" type="number" placeholder="e.g., 250" value="250" step="1" min="0"></label>
      <label>P₀ (W)<input id="power0" type="number" placeholder="e.g., 600" value="600" step="10" min="0"></label>
      <label>hA (W / °C)<input id="heatLoss" type="number" placeholder="e.g., 1.1" value="1.1" step="0.1" min="0"></label>
      <label>Room T (°C)<input id="roomTemp" type="number" placeholder="e.g., 22" value="22" step="0.1"></label>
    </details>
  </div>
  <button id="startBtn" type="button">START</button>
  <div id="progressWrap"><div id="progressBar"></div><span id="barLabel"></span></div>
  <div id="status"></div>
  <div id="info"></div>
</div>
<footer>tap anywhere (except progress bar/controls) to stop simulation & flashing</footer>

<!-- Debug Output Area -->
<div id="debugContainer" style="display: none;">
    <div id="debugHeader">
        <span>Debug Log</span>
        <button id="clearDebug">Clear</button>
    </div>
    <div id="debugOutput"></div>
</div>
<button id="toggleDebug">Show Debug Log</button>

<script>
// --- Debug Output ---
const debugOutput = document.getElementById('debugOutput');
const debugContainer = document.getElementById('debugContainer');
const toggleDebugBtn = document.getElementById('toggleDebug');
const clearDebugBtn = document.getElementById('clearDebug');
let isDebugVisible = false;

function logToPage(message, type = 'log') {
    if (!debugOutput) return;
    const entry = document.createElement('div');
    entry.classList.add(`debug-${type}`);
    const time = new Date().toLocaleTimeString([], { hour12: false });
    entry.textContent = `[${time}] ${message}`;
    debugOutput.appendChild(entry);
    // Auto-scroll to bottom
    debugOutput.scrollTop = debugOutput.scrollHeight;
}

// Store original console methods
const originalConsole = {
    log: console.log.bind(console),
    warn: console.warn.bind(console),
    error: console.error.bind(console),
    // Add more if needed (info, debug, etc.)
};

// Override console methods
console.log = function(...args) {
    originalConsole.log.apply(console, args); // Keep original behavior
    const message = args.map(arg => (typeof arg === 'object' && arg !== null) ? JSON.stringify(arg) : String(arg)).join(' ');
    logToPage(message, 'log');
};
console.warn = function(...args) {
    originalConsole.warn.apply(console, args);
    const message = args.map(arg => (typeof arg === 'object' && arg !== null) ? JSON.stringify(arg) : String(arg)).join(' ');
    logToPage(message, 'warn');
};
console.error = function(...args) {
    originalConsole.error.apply(console, args);
    const message = args.map(arg => (typeof arg === 'object' && arg !== null) ? JSON.stringify(arg) : String(arg)).join(' ');
    logToPage(message, 'error');
};

// Debug toggle/clear functionality
toggleDebugBtn.addEventListener('click', () => {
    isDebugVisible = !isDebugVisible;
    debugContainer.style.display = isDebugVisible ? 'block' : 'none';
    toggleDebugBtn.textContent = isDebugVisible ? 'Hide Debug Log' : 'Show Debug Log';
});
clearDebugBtn.addEventListener('click', () => {
    if(debugOutput) debugOutput.innerHTML = '';
});

console.log("Debug logger initialized."); // Test the logger

// --- Constants & Persistence ---
const KEY = "microwaveTimerSettings_sim";
const SIMULATION_INTERVAL_MS = 250;
const cW = 4186, cC = 880;

function saveSettings() {
    if (state === "idle") {
        localStorage.setItem(KEY, JSON.stringify({
        start:+startTemp.value,target:+targetTemp.value,
        water:+waterMass.value,mug:+mugMass.value,
        P0:+power0.value,hA:+heatLoss.value,room:+roomTemp.value
        }));
        console.log("Settings saved:", JSON.parse(localStorage.getItem(KEY))); // Log saved settings
    }
}
function loadSettings() {
    try{
        const d=JSON.parse(localStorage.getItem(KEY)||"{}");
        console.log("Attempting to load settings:", d); // Log loaded settings
        if(d.start && typeof d.start === 'number') $('startTemp').value=d.start;
        if(d.target && typeof d.target === 'number') $('targetTemp').value=d.target;
        if(d.water && typeof d.water === 'number') $('waterMass').value=d.water;
        if(d.mug && typeof d.mug === 'number') $('mugMass').value=d.mug;
        if(d.P0 && typeof d.P0 === 'number') $('power0').value=d.P0;
        if(d.hA && typeof d.hA === 'number') $('heatLoss').value=d.hA;
        if(d.room && typeof d.room === 'number') $('roomTemp').value=d.room;
        console.log("Settings loaded successfully.");
    }catch(e){ console.error("Error loading settings:", e); }
}

// --- Helpers ---
const $ = id => document.getElementById(id);

function fmtTime(s) {
    if (s === null || typeof s === 'undefined' || isNaN(s)) { return "--:--"; }
    if (!isFinite(s)) { return "∞"; }
    s = Math.max(0, Math.round(s));
    const m = Math.floor(s / 60);
    const sec = s % 60;
    return m > 0 ? m + ":" + sec.toString().padStart(2, "0") : sec.toString();
}

// --- Physics Model ---
function getParams() {
    console.log("Getting parameters...");
    const parseFloatOrDefault = (elementId, defaultValue, minValue = -Infinity) => {
        const inputElement = $(elementId);
        if (!inputElement) { console.error(`Element with ID '${elementId}' not found.`); return defaultValue; }
        const val = parseFloat(inputElement.value);
        if (isNaN(val) || inputElement.value.trim() === "") {
             console.warn(`Using default value for ${elementId} (value: "${inputElement.value}")`);
             return defaultValue;
        }
        if (val < minValue) {
             console.warn(`Value for ${elementId} (${val}) is below minimum (${minValue}), using minimum.`);
             return minValue;
        }
        return val;
    };
    const T0 = parseFloatOrDefault('startTemp', 10);
    const Tt = parseFloatOrDefault('targetTemp', 80);
    const mW = parseFloatOrDefault('waterMass', 300, 1) / 1000;
    const mM = parseFloatOrDefault('mugMass', 250, 0) / 1000;
    const P0 = parseFloatOrDefault('power0', 600, 0);
    const hA = parseFloatOrDefault('heatLoss', 1.0, 0);
    const Ta = parseFloatOrDefault('roomTemp', 22);
    const MC = mW * cW + mM * cC;
    if (MC <= 0) { console.error("Calculated MC is <= 0.", {mW, mM, cW, cC}); return null; }
    const params = { T0, Tt, P0, hA, Ta, MC };
    console.log("Parameters retrieved:", params);
    return params;
}

function calculateDeltaT(params, currentTemp, deltaTime, isHeating) {
    if (!params || params.MC <= 0 || deltaTime <= 0) {
        // console.log("Skipping deltaT calc (invalid params/MC/deltaTime)"); // Can be noisy
        return 0;
    }
    const powerInput = isHeating ? params.P0 : 0;
    const hA_safe = Math.max(0, params.hA); // Ensure non-negative
    const powerLoss = hA_safe * (currentTemp - params.Ta);
    const netPower = powerInput - powerLoss;
    const dT_dt = netPower / params.MC;
    const deltaT = dT_dt * deltaTime;
    // console.log(`DeltaT Calc: T=${currentTemp.toFixed(2)}, dT=${deltaT.toFixed(4)}, dt=${deltaTime.toFixed(3)}, heating=${isHeating}, P0=${powerInput}, Ploss=${powerLoss.toFixed(2)}, NetP=${netPower.toFixed(2)}`); // Very verbose log
    return deltaT;
}

function estimateRemainingTime(params, currentTemp) {
    if (!params || params.MC <= 0) { return NaN; }
    const targetTemp = params.Tt;
    if (currentTemp >= targetTemp) { return 0; }
    const P0_safe = Math.max(0, params.P0);
    const hA_safe = Math.max(0, params.hA);
    if (P0_safe <= 0 && currentTemp < targetTemp) { return Infinity; } // Heating needed but no power

    const maxReachableTemp = (hA_safe > 0) ? params.Ta + (P0_safe / hA_safe) : Infinity;
    if (targetTemp > maxReachableTemp) {
        console.warn(`Target (${targetTemp}°C) is unreachable. Max possible ≈ ${maxReachableTemp.toFixed(1)}°C`);
        return Infinity;
    }

    // Handle zero heat loss case separately
    if (hA_safe <= 0) {
        if (P0_safe <= 0) return Infinity; // Should have been caught above, but safety
        return (params.MC * (targetTemp - currentTemp)) / P0_safe;
    }

    // Standard case with heat loss
    const numerator = P0_safe - hA_safe * (currentTemp - params.Ta);
    const denominator = P0_safe - hA_safe * (targetTemp - params.Ta);

    // Check for edge cases / potential division by zero or log of non-positive
    if (numerator <= 0 && currentTemp < targetTemp) {
        console.warn("Cannot reach target from current temp (numerator <= 0). Current heat loss >= P0.");
        return Infinity; // Already losing heat faster than gaining, or at equilibrium below target
    }
     if (denominator <= 0) {
        // This case implies targetTemp >= maxReachableTemp, should be caught by the check above
        console.warn("Denominator issue in time estimation (target likely unreachable).");
        return Infinity;
    }

    const time = (params.MC / hA_safe) * Math.log(numerator / denominator);
    return isNaN(time) ? NaN : Math.max(0, time); // Ensure non-negative time
}

// --- State Management ---
let state = "idle";
let simulationInterval = null;
let flashInterval = null;
let sim = {
    params: null, currentTemperature: 0, initialTemperature: 0,
    targetTemperature: 0, lastTickTime: 0
};

// --- UI Update Functions ---
function updateUI() {
    // console.log("Updating UI for state:", state); // Can be noisy
    if (state === 'idle') {
        updatePredictedTimeFromInputs();
        $('progressWrap').style.display = 'none';
        $('barLabel').textContent = '';
        return;
    }
    const tempDisplay = isNaN(sim.currentTemperature) ? "--" : sim.currentTemperature.toFixed(1);
    $('barLabel').textContent = tempDisplay + "°";
    const tempRange = sim.targetTemperature - sim.initialTemperature;
    let progress = 0;
    if (tempRange > 0 && !isNaN(sim.currentTemperature)) {
        progress = ((sim.currentTemperature - sim.initialTemperature) / tempRange) * 100;
    } else if (!isNaN(sim.currentTemperature) && sim.currentTemperature >= sim.targetTemperature) {
        progress = 100;
    }
    progress = Math.max(0, Math.min(100, progress));
    $('progressBar').style.width = progress + '%';
    if (state === 'heating' || state === 'paused') {
        const remaining = estimateRemainingTime(sim.params, sim.currentTemperature);
        $('info').textContent = fmtTime(remaining) + (isFinite(remaining) ? " s" : "");
    } else if (state === 'finished') {
        $('info').textContent = "0 s";
    }
}

function updateControlsOnIdle() {
    const startVal = $('startTemp').value;
    const targetVal = $('targetTemp').value;
    $('startVal').textContent = parseFloat(startVal).toFixed(1) + " °C";
    $('targetVal').textContent = parseFloat(targetVal).toFixed(0) + " °C";
    updatePredictedTimeFromInputs(); // Recalculate time estimate based on inputs
}

function updatePredictedTimeFromInputs() {
    const p = getParams(); // Get current params from inputs
    if (!p) { $('info').textContent = "Invalid Params"; return; }
    const t = estimateRemainingTime(p, p.T0); // Estimate based on *start* temp T0
    let displayTime;
    if (p.T0 >= p.Tt) {
         displayTime = "Start ≥ Target";
    } else if (t === null || isNaN(t)) {
        displayTime = "Invalid Calc";
    } else if (!isFinite(t)) {
        displayTime = "∞ (Unreachable)";
    } else {
        displayTime = fmtTime(t) + " s";
    }
    $('info').textContent = displayTime;
     console.log(`Predicted time from inputs: ${displayTime}`);
}


function updateUIForStateChange() {
    console.log(`Updating UI for state change to: ${state}`);
    const isIdle = state === "idle";
    const isRunning = !isIdle;
    $('startBtn').style.display = isIdle ? 'block' : 'none';
    $('progressWrap').style.display = isRunning ? 'block' : 'none';
    [startTemp, targetTemp, waterMass, mugMass, power0, heatLoss, roomTemp].forEach(el => {
        el.disabled = isRunning;
        // Also disable the details summary click when running? Maybe not necessary.
        const details = el.closest('details');
        if (details) details.open = !isRunning; // Close details when running
    });
    switch (state) {
        case "idle": $('status').textContent = ""; break;
        case "heating": $('status').textContent = "Heating"; break;
        case "paused": $('status').textContent = "Paused"; break;
        case "finished": $('status').textContent = "Finished!"; break;
    }
    if (state !== "finished") { stopFlash(); } // Ensure flash stops if not finished
}

// --- Simulation Loop ---
function simulationStep() {
    if (state === 'idle' || !sim.params) return;

    const now = Date.now();
    let deltaTime = (now - sim.lastTickTime) / 1000;
    sim.lastTickTime = now;

    if (deltaTime <= 0) return; // Avoid issues if clock jumps back or zero time passes
    // Optional: Cap deltaTime to prevent huge jumps if tab was inactive
    // deltaTime = Math.min(deltaTime, 0.5); // e.g., max half-second step

    const isHeating = (state === 'heating');
    const deltaT = calculateDeltaT(sim.params, sim.currentTemperature, deltaTime, isHeating);

    let nextTemperature = sim.currentTemperature;

    if (!isNaN(deltaT)) {
        nextTemperature += deltaT;
    } else {
        console.error("deltaT is NaN, stopping simulation.");
        setState('idle');
        return;
    }

    // --- Clamping Logic ---
    // Prevent cooling below room temperature ONLY if heat loss is positive
    // And only if the step would actually take it below room temp
    if (!isHeating && sim.params.hA > 0 && nextTemperature < sim.params.Ta && sim.currentTemperature >= sim.params.Ta) {
        // console.log(`Clamping cooling: Next temp ${nextTemperature.toFixed(2)} < Room temp ${sim.params.Ta}. Setting to ${sim.params.Ta}`);
        sim.currentTemperature = sim.params.Ta;
    } else {
        // Otherwise, update normally (heating, or cooling towards Ta from above/below, or no heat loss)
        sim.currentTemperature = nextTemperature;
    }
    // --- End of Clamping Logic ---

    // Check for finish condition AFTER updating temperature
    if (isHeating && sim.currentTemperature >= sim.targetTemperature) {
        console.log(`Target reached! Current: ${sim.currentTemperature.toFixed(2)}, Target: ${sim.targetTemperature}`);
        sim.currentTemperature = sim.targetTemperature; // Clamp exactly to target
        updateUI(); // Update UI one last time before state change
        setState("finished");
    } else {
        updateUI(); // Regular update during heating/paused
    }
}

// --- State Transition Logic ---
function setState(newState) {
    if (state === newState) {
         console.log(`setState called with same state: ${newState}, ignoring.`);
         return; // No change
    }
    const previousState = state;
    state = newState;
    console.log(`State transition: ${previousState} -> ${newState}`);
    updateUIForStateChange(); // Update buttons/visibility/disabled status

    if (newState === 'idle') {
        stopSimulation(); // Stops interval and flash
        updateControlsOnIdle(); // Update display values and estimated time
    } else {
        if (previousState === 'idle') {
            startSimulation(); // Starts interval if transitioning from idle
        }
        if (newState === 'finished') {
            playChime();
            beginFlash();
        }
        // Ensure simulation keeps running if paused->heating or heating->paused
        // If heating or paused, ensure interval is running (startSimulation handles this)
        if (newState === 'heating' || newState === 'paused') {
             startSimulation(); // Safe to call even if running
        }

    }
    updateUI(); // Update progress bar, temperature display, remaining time
}

// --- Simulation Control ---
function startSimulation() {
    if (!simulationInterval) { // Only start if not already running
       console.log("Starting simulation interval");
       sim.lastTickTime = Date.now(); // Reset tick time when starting/resuming
       simulationInterval = setInterval(simulationStep, SIMULATION_INTERVAL_MS);
    } else {
        // console.log("Simulation interval already running."); // Debug if needed
    }
}

function stopSimulation() {
    if (simulationInterval) {
        console.log("Stopping simulation interval");
        clearInterval(simulationInterval);
        simulationInterval = null;
    }
    stopFlash(); // Always ensure flash stops when simulation stops
}

// --- Actions ---
function startAction() {
    if (state !== 'idle') { return; }
    console.log("Start button clicked.");
    initializeAudio(); // Ensure audio is ready on user interaction
    sim.params = getParams();
    if (!sim.params) {
        $('info').textContent = "Invalid Params";
        console.error("Cannot start: Invalid parameters.");
        return;
    }
    sim.initialTemperature = sim.params.T0;
    sim.targetTemperature = sim.params.Tt;
    sim.currentTemperature = sim.params.T0; // Start at initial temp

    // Pre-flight check: Can the target be reached?
    const initialEstimate = estimateRemainingTime(sim.params, sim.currentTemperature);
    if (sim.params.T0 >= sim.params.Tt) {
         $('info').textContent = "Start ≥ Target";
         console.warn("Cannot start: Start temperature is already at or above target.");
         return;
    }
     if (initialEstimate === null || isNaN(initialEstimate) || !isFinite(initialEstimate)) {
         $('info').textContent = "∞ (Unreachable)";
         console.warn("Cannot start: Target temperature seems unreachable with current parameters.");
         return;
    }

    console.log("Starting heating process...");
    setState("heating");
}

function pauseAction() {
    if (state === 'heating') {
        console.log("Pause action triggered.");
        setState('paused');
    }
}
function resumeAction() {
     if (state === 'paused') {
        console.log("Resume action triggered.");
        sim.lastTickTime = Date.now(); // Important: reset time to avoid large jump after pause
        setState('heating');
     }
}
function stopAction() {
    if (state !== 'idle') {
        console.log("Stop action triggered (via body click or explicit call).");
        setState('idle');
    }
}

// --- Audio & Visual Feedback ---
let audioCtx = null; // Initialize audio context lazily

function initializeAudio() {
    if (!audioCtx && (window.AudioContext || window.webkitAudioContext)) {
        try {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            console.log("AudioContext initialized.");
            // Resume if suspended (often needed on first interaction)
            if (audioCtx.state === 'suspended') {
                audioCtx.resume().then(() => console.log("AudioContext resumed."))
                                .catch(e => console.error("Error resuming AudioContext:", e));
            }
        } catch (e) {
            console.error("Web Audio API is not supported or initialization failed.", e);
            audioCtx = null; // Ensure it's null if failed
        }
    }
}

// Basic chime function
function playChime(){
    // Ensure audio context is ready (should have been called by user interaction already)
    if (!audioCtx) {
        console.warn("AudioContext not available, cannot play chime.");
        initializeAudio(); // Try one last time
        if (!audioCtx) return;
    }
     // Check state again after potential resume attempt
    if (audioCtx.state !== 'running') {
        console.warn(`AudioContext state is ${audioCtx.state}, attempting to resume for chime...`);
        audioCtx.resume().then(() => {
             console.log("AudioContext resumed for chime, trying again.");
             playChimeInternal(); // Try playing now that it's resumed
        }).catch(e => console.error("Error resuming AudioContext for chime:", e));
    } else {
        playChimeInternal(); // Play directly if already running
    }
}

function playChimeInternal() {
     if (!audioCtx || audioCtx.state !== 'running') {
          console.error("Cannot play chime, AudioContext not running.");
          return;
     }
    console.log("Attempting to play chime...");
    try {
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(880, audioCtx.currentTime); // A5
        gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.8);
        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + 0.8);
        console.log("Chime sound generated.");
    } catch (e) {
        console.error("Error playing chime sound:", e);
    }
}


// --- Flashing Logic ---
function beginFlash(){
    console.log(">>> beginFlash called. Current state:", state);
    if (flashInterval) {
        console.log(">>> Flash already running, exiting beginFlash.");
        return;
    }

    // --- DEBUG: Immediately change background to show function was called ---
    // Set a highly visible color first.
    document.body.style.backgroundColor = 'purple'; // DEBUG COLOR
    console.log(">>> DEBUG: Set background to purple.");
    // We need a slight delay before starting the interval to ensure the purple is rendered
    // and the subsequent class toggle doesn't happen in the same paint cycle.
    setTimeout(() => {
        console.log(">>> Starting flash interval now.");
        let on = false; // Start with flash "off" visually (body default or purple)
        document.body.classList.remove('flash-green'); // Ensure it starts "off"

        flashInterval = setInterval(() => {
            on = !on;
            document.body.classList.toggle('flash-green', on);
            // console.log(">>> Flash toggle:", on ? "ON (Green)" : "OFF (Default/Purple)"); // Can be noisy
        }, 600); // Interval for flashing (milliseconds)
        console.log(">>> Flash interval started. Interval ID:", flashInterval);
    }, 50); // Small delay (50ms)
}

function stopFlash(){
    console.log(">>> stopFlash called.");
    if (flashInterval) {
        clearInterval(flashInterval);
        flashInterval = null;
        console.log(">>> Flash interval cleared.");
    }
    // Clean up styles explicitly
    document.body.classList.remove('flash-green');
    document.body.style.backgroundColor = ''; // Reset direct style to allow CSS variables to take over
    console.log(">>> flash-green class removed, direct background style reset.");
}


// --- Event Binding ---
$('startBtn').addEventListener('click', startAction); // initializeAudio is called inside startAction

$('progressWrap').addEventListener('click', () => {
    initializeAudio(); // Ensure context is active for potential future sounds
    if (state === 'heating') { pauseAction(); }
    else if (state === 'paused') { resumeAction(); }
});

// Stop simulation/flashing on tap outside controls/progress bar
document.body.addEventListener('click', (e) => {
    // Prevent body click from stopping if the click originated from controls/progress/debug area
    const isProgressClick = e.target === $('progressWrap') || $('progressWrap').contains(e.target);
    const isControlClick = e.target.closest('#controls') || e.target === $('startBtn');
    const isDebugClick = e.target.closest('#debugContainer') || e.target === toggleDebugBtn;

    if (!isProgressClick && !isControlClick && !isDebugClick && state !== 'idle') {
        console.log("Body click detected outside interactive elements, stopping.");
        initializeAudio(); // Ensure context active before potential state change sound later
        stopAction();
    } else if (!isDebugClick) {
        // Any other click might be the first interaction needed for audio
        initializeAudio();
    }
});

// Input listeners
[startTemp, targetTemp, waterMass, mugMass, power0, heatLoss, roomTemp].forEach(el => {
  el.addEventListener('input', () => { if (state === 'idle') { updateControlsOnIdle(); } });
  el.addEventListener('change', () => { if (state === 'idle') { saveSettings(); updateControlsOnIdle(); } });
});

// --- Initialization ---
document.addEventListener('DOMContentLoaded', (event) => {
    console.log("DOM Content Loaded.");
    loadSettings();
    updateControlsOnIdle(); // Set initial display values based on loaded/default settings
    setState("idle"); // Set initial state explicitly
    // Hide debug initially unless needed
    debugContainer.style.display = 'none';
    isDebugVisible = false;
    toggleDebugBtn.textContent = 'Show Debug Log';
});

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
    console.log("Page unloading, stopping simulation.");
    stopSimulation();
    // No need to save settings here, it's done on 'change' when idle
});

</script>
</body>
</html>