<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Microwave Timer - Simulation Centric (Fix)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
:root {
  --bg: #0d0d0d; --card: #161616; --text: #e8e8e8; --muted: #7a7a7a;
  --track: #1f1f1f; --fill-start: #005f99; --fill-end: #008644;
  --radius: 14px; --space: clamp(0.9rem,3vw,1.4rem);
  --mono: 'SFMono-Regular','Consolas','Liberation Mono',monospace;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
  background: var(--bg); color: var(--text);
  font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  padding: var(--space); display: flex; flex-direction: column; min-height: 100vh;
  transition: background-color 0.2s ease-in-out;
}
header { text-align: center; margin-bottom: clamp(1.2rem,4vw,2rem); }
h1 { font-size: clamp(1.6rem,4vw,2rem); font-weight: 600; }
h1 small { display: block; font-size: .78em; color: var(--muted); }
#card {
  background: var(--card); padding: var(--space); border-radius: var(--radius);
  box-shadow: 0 6px 18px rgba(0,0,0,0.35); flex: 1; display: flex; flex-direction: column;
}
#controls { display: block; }
.field { margin-top: var(--space); }
label { display: block; margin-bottom: .25rem; font-size: 1.05rem; color: var(--muted); }
input[type=range] {
  width: 100%; height: 6px; background: #444; border-radius: 4px; outline: none;
  appearance: none; margin: .35rem 0;
}
input[type=range]:disabled { opacity: 0.5; }
input[type=range]::-webkit-slider-thumb {
  appearance: none; width: 22px; height: 22px; border-radius: 50%;
  background: var(--fill-end); border: none; cursor: pointer;
}
input[type=range]:disabled::-webkit-slider-thumb { cursor: not-allowed; background: #555; }
.value-display { margin-left: .4rem; font-size: 1.6rem; font-weight: 600; color: var(--text); }
details { margin-top: var(--space); border-top: 1px dashed #333; padding-top: var(--space); }
summary { cursor: pointer; color: var(--fill-end); font-weight: 500; }
input[type=number] {
  width: 100%; padding: .6rem .8rem; margin-top: .25rem; font-size: 1rem;
  border: 1px solid #333; border-radius: var(--radius); background: #000; color: var(--text);
}
input[type=number]:disabled { background: #111; color: #777; cursor: not-allowed; }
#startBtn {
  width: 100%; height: 54px; margin-top: var(--space); border-radius: var(--radius);
  background: linear-gradient(90deg, var(--fill-start), var(--fill-end));
  border: none; color: #000; font-size: 1.25rem; font-weight: 600; cursor: pointer;
}
#progressWrap {
  width: 100%; height: 54px; margin-top: var(--space); border-radius: var(--radius);
  background: var(--track); overflow: hidden; position: relative; display: none; cursor: pointer;
}
#progressBar {
  height: 100%; width: 0%;
  background: linear-gradient(90deg, var(--fill-start), var(--fill-end));
  transition: width 0.2s linear;
}
#barLabel {
  position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
  font-family: var(--mono); font-size: 1.4rem; color: #fff;
  text-shadow: 0 0 4px rgba(0,0,0,0.6); pointer-events: none;
}
#status {
  margin-top: var(--space); text-align: center; font-family: var(--mono);
  font-size: 1rem; color: var(--muted); min-height: 1.2em;
}
#info { /* Now displays estimated remaining time */
  margin-top: var(--space); text-align: center; font-family: var(--mono);
  font-size: 2.4rem; min-height: 1.2em;
}
footer {
  margin-top: var(--space); text-align: center; font-size: 0.85rem;
  color: var(--muted); font-style: italic;
}
body.flash-green { background-color: var(--fill-end); }
</style>
</head>
<body>
<header>
  <h1>Microwave Timer<small>Simulation Centric (Fix)</small></h1>
</header>
<div id="card">
  <div id="controls">
     <!-- Inputs -->
     <div class="field">
      <label>Start <span id="startVal" class="value-display">? °C</span></label>
      <input id="startTemp" type="range" min="5" max="20" step="0.1" value="13">
    </div>
    <div class="field">
      <label>Target <span id="targetVal" class="value-display">? °C</span></label>
      <input id="targetTemp" type="range" min="75" max="90" step="1" value="80">
    </div>
    <details>
      <summary>Advanced</summary>
      <label>Water mass (g)<input id="waterMass" type="number" placeholder="e.g., 300" value="303" step="1" min="1"></label>
      <label>Mug mass (g)<input id="mugMass" type="number" placeholder="e.g., 250" value="250" step="1" min="0"></label>
      <label>P₀ (W)<input id="power0" type="number" placeholder="e.g., 600" value="600" step="10" min="0"></label>
      <label>hA (W / °C)<input id="heatLoss" type="number" placeholder="e.g., 1.1" value="1.1" step="0.1" min="0"></label>
      <label>Room T (°C)<input id="roomTemp" type="number" placeholder="e.g., 22" value="22" step="0.1"></label>
    </details>
  </div>
  <button id="startBtn" type="button">START</button>
  <div id="progressWrap"><div id="progressBar"></div><span id="barLabel"></span></div>
  <div id="status"></div>
  <div id="info"></div>
</div>
<footer>tap anywhere (except progress bar/controls) to stop simulation & flashing</footer>

<script>
// --- Constants & Persistence ---
const KEY = "microwaveTimerSettings_sim";
const SIMULATION_INTERVAL_MS = 250;
const cW = 4186, cC = 880;

function saveSettings() { /* ... same as before ... */ }
function loadSettings() { /* ... same as before ... */ }

// --- Helpers ---
const $ = id => document.getElementById(id);

// *** UPDATED fmtTime ***
function fmtTime(s) {
    // Explicitly handle non-numeric input BEFORE calculations
    if (s === null || typeof s === 'undefined' || isNaN(s)) {
        // console.warn("fmtTime received invalid input:", s);
        return "--:--"; // Or return "Invalid" or similar indicator
    }
    if (!isFinite(s)) {
        return "∞"; // Handle Infinity explicitly if needed elsewhere
    }

    s = Math.max(0, Math.round(s)); // Proceed with valid number
    const m = Math.floor(s / 60);
    const sec = s % 60;
    // Use minutes if m > 0, otherwise just show seconds
    return m > 0 ? m + ":" + sec.toString().padStart(2, "0") : sec.toString();
}

// --- Physics Model ---
// *** UPDATED getParams with validation ***
function getParams() {
    // Helper to parse float and provide default if NaN or invalid
    const parseFloatOrDefault = (elementId, defaultValue, minValue = -Infinity) => {
        const val = parseFloat($(elementId).value);
        // Use defaultValue if NaN, less than minValue, or if original input was empty string
        // (parseFloat("") is NaN)
        return (isNaN(val) || val < minValue) ? defaultValue : val;
    };

    // Use parseFloat for sliders as well for consistency
    const T0 = parseFloatOrDefault('startTemp', 10);
    const Tt = parseFloatOrDefault('targetTemp', 80);
    // Ensure masses/power are non-negative, provide defaults
    const mW = parseFloatOrDefault('waterMass', 300, 0) / 1000; // Default 300g, min 0
    const mM = parseFloatOrDefault('mugMass', 250, 0) / 1000;   // Default 250g, min 0
    const P0 = parseFloatOrDefault('power0', 600, 0);         // Default 600W, min 0
    // Ensure hA is non-negative (hA=0 means no heat loss)
    const hA = parseFloatOrDefault('heatLoss', 1.0, 0);       // Default 1.0, min 0
    // Room temp can be negative, use a reasonable default
    const Ta = parseFloatOrDefault('roomTemp', 22);           // Default 22C

    const MC = mW * cW + mM * cC;
    // Add a check for MC <= 0 which would break calculations
    if (MC <= 0) {
        console.error("Calculated MC is <= 0. Check masses.", {mW, mM});
        // Return null or throw error to prevent starting with invalid params?
        // For now, let's allow it but calculations might yield NaN/Infinity.
    }

    return { T0, Tt, P0, hA, Ta, MC };
}

function calculateDeltaT(params, currentTemp, deltaTime, isHeating) {
    // Add checks for invalid parameters that could lead to NaN/Infinity
    if (!params || params.MC <= 0 || deltaTime <= 0) return 0;

    const powerInput = isHeating ? params.P0 : 0;
    // Ensure hA is non-negative before using it
    const hA_safe = Math.max(0, params.hA);
    const powerLoss = hA_safe * (currentTemp - params.Ta);
    const netPower = powerInput - powerLoss;

    const dT_dt = netPower / params.MC;
    return dT_dt * deltaTime;
}

function estimateRemainingTime(params, currentTemp) {
    // Add checks for invalid parameters
    if (!params || params.MC <= 0) return NaN; // Indicate invalid calculation

    const targetTemp = params.Tt;
    if (currentTemp >= targetTemp) return 0;

    // Ensure P0 and hA are valid numbers >= 0 for checks
    const P0_safe = Math.max(0, params.P0);
    const hA_safe = Math.max(0, params.hA);

    if (P0_safe <= 0) return Infinity; // No power input

    const maxReachableTemp = (hA_safe > 0) ? params.Ta + (P0_safe / hA_safe) : Infinity;

    if (targetTemp > maxReachableTemp) return Infinity;

    // Handle no heat loss case (hA = 0)
    if (hA_safe <= 0) {
        return (params.MC * (targetTemp - currentTemp)) / P0_safe;
    }

    // Proceed with log calculation for hA > 0
    const numerator = P0_safe - hA_safe * (currentTemp - params.Ta);
    const denominator = P0_safe - hA_safe * (targetTemp - params.Ta);

    if (numerator <= 0 || denominator <= 0) {
        // This can happen if currentTemp or targetTemp is exactly the equilibrium temp,
        // or slightly above due to float inaccuracies.
        // If current is below target, it implies target is unreachable or at equilibrium -> Infinity
        return (currentTemp < targetTemp) ? Infinity : 0;
    }

    const time = (params.MC / hA_safe) * Math.log(numerator / denominator);
    // Final check if calculation resulted in NaN for any reason
    return isNaN(time) ? NaN : time;
}

// --- State Management ---
let state = "idle";
let simulationInterval = null;
let flashInterval = null;
let sim = {
    params: null, currentTemperature: 0, initialTemperature: 0,
    targetTemperature: 0, lastTickTime: 0
};

// --- UI Update Functions ---
// *** UPDATED updateUI ***
function updateUI() {
    if (state === 'idle') {
        updatePredictedTimeFromInputs();
        $('progressWrap').style.display = 'none';
        $('barLabel').textContent = '';
        return;
    }

    // Ensure temp is a number before displaying
    const tempDisplay = isNaN(sim.currentTemperature) ? "--" : sim.currentTemperature.toFixed(1);
    $('barLabel').textContent = tempDisplay + "°";

    // Update progress bar
    const tempRange = sim.targetTemperature - sim.initialTemperature;
    let progress = 0;
    if (tempRange > 0 && !isNaN(sim.currentTemperature)) {
        progress = ((sim.currentTemperature - sim.initialTemperature) / tempRange) * 100;
    } else if (sim.currentTemperature >= sim.targetTemperature) {
        progress = 100;
    }
    progress = Math.max(0, Math.min(100, progress));
    $('progressBar').style.width = progress + '%';

    // Update estimated remaining time display
    if (state === 'heating' || state === 'paused') {
        const remaining = estimateRemainingTime(sim.params, sim.currentTemperature);
        // Use the robust fmtTime which handles NaN/Infinity/undefined
        $('info').textContent = fmtTime(remaining) + (isFinite(remaining) ? " s" : "");
    } else if (state === 'finished') {
        $('info').textContent = "0 s";
    }
}

function updateControlsOnIdle() { /* ... same as before ... */ }
function updatePredictedTimeFromInputs() { /* ... same as before, but uses updated estimateRemainingTime */ }
function updateUIForStateChange() { /* ... same as before ... */ }


// --- Simulation Loop ---
function simulationStep() { /* ... (logic mostly same, relies on updated calculateDeltaT) ... */
    if (state === 'idle' || !sim.params) return;

    const now = Date.now();
    const deltaTime = (now - sim.lastTickTime) / 1000;
    sim.lastTickTime = now;

    if (deltaTime <= 0) return;

    const isHeating = (state === 'heating');
    const deltaT = calculateDeltaT(sim.params, sim.currentTemperature, deltaTime, isHeating);

    // Prevent temp becoming NaN if deltaT calculation failed
    if (!isNaN(deltaT)) {
        sim.currentTemperature += deltaT;
    } else {
        console.warn("deltaT is NaN, stopping simulation.");
        setState('idle'); // Or show an error state
        return;
    }

     // Clamp to room temp when cooling
     if (!isHeating && sim.params.hA > 0 && sim.currentTemperature < sim.params.Ta) {
         sim.currentTemperature = sim.params.Ta;
     }

    // Check for reaching target ONLY when heating
    if (isHeating && sim.currentTemperature >= sim.targetTemperature) {
        sim.currentTemperature = sim.targetTemperature;
        updateUI(); // Update UI one last time before changing state
        setState("finished");
    } else {
        // Update UI normally if not finished
        updateUI();
    }
}

// --- State Transition Logic ---
function setState(newState) { /* ... same as before ... */ }

// --- Simulation Control ---
function startSimulation() { /* ... same as before ... */ }
function stopSimulation() { /* ... same as before ... */ }

// --- Actions ---
function startAction() {
     if (state !== 'idle') return;

    sim.params = getParams(); // Uses robust getParams
    // Add extra validation after getting params
    if (!sim.params || sim.params.MC <= 0) {
         $('info').textContent = "Invalid Params";
         console.error("Cannot start: Invalid parameters or MC <= 0", sim.params);
         return;
    }

    sim.initialTemperature = sim.params.T0;
    sim.targetTemperature = sim.params.Tt;
    sim.currentTemperature = sim.params.T0;

    const initialEstimate = estimateRemainingTime(sim.params, sim.currentTemperature);
    // Check for NaN explicitly now from estimateRemainingTime
    if (initialEstimate === null || isNaN(initialEstimate) || !isFinite(initialEstimate)) {
         $('info').textContent = (initialEstimate === null || sim.params.T0 >= sim.params.Tt) ? "Start ≥ Target" : "∞ (Unreachable)";
         // Also log why it might be unreachable
         if (!isFinite(initialEstimate) && initialEstimate !== null) {
             console.warn("Target potentially unreachable with current params:", sim.params);
         }
         return;
    }

    setState("heating");
}

function pauseAction() { /* ... same as before ... */ }
function resumeAction() { /* ... same as before ... */ }
function stopAction() { /* ... same as before ... */ }

// --- Audio & Visual Feedback --- (no changes needed)
let audioCtx = null;
function playChime(){ /* ... same as before ... */ }
function beginFlash(){ /* ... same as before ... */ }
function stopFlash(){ /* ... same as before ... */ }

// --- Event Binding --- (no changes needed)
$('startBtn').addEventListener('click', startAction);
$('progressWrap').addEventListener('click', () => { /* ... */ });
document.body.addEventListener('click', (e) => { /* ... */ });
[startTemp, targetTemp, waterMass, mugMass, power0, heatLoss, roomTemp].forEach(el => { /* ... */ });

// --- Initialization --- (no changes needed)
loadSettings();
updateControlsOnIdle();
setState("idle");
window.addEventListener('beforeunload', () => { stopSimulation(); });

</script>
</body>
</html>