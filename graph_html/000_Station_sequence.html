<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Untitled</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: light dark; }
    body { margin: 0; font-family: "Segoe UI", Arial, sans-serif; background: #f5f7fa; color: #1f2933; }
    main { padding: 32px; box-sizing: border-box; }
    h1 { margin: 0 0 24px; font-size: 24px; font-weight: 600; }

    .diagram { position: relative; overflow: visible; }
    .diagram-content { display: grid; gap: 20px 16px; align-items: start; padding-bottom: 160px; width: max-content; }
    .cell { min-height: 8px; display: flex; justify-content: center; }

    .step-card, .transition-card { display: flex; flex-direction: column; gap: 8px; box-sizing: border-box; background: #ffffff; border: 1px solid #d2d6dc; box-shadow: 0 10px 30px rgba(31, 41, 51, 0.08); padding: 14px 16px; min-width: 220px; }
    .step-card { border-color: #9ac6dd; border-radius: 0; width: 100%; }
    .transition-card { border: 1px solid #9aa3af; background: #f7f8fa; border-radius: 16px; width: max-content; margin-left: 12px; margin-right: 12px; box-shadow: none; padding: 8px 16px; }
    .step-card .header, .transition-card .header { display: flex; flex-direction: column; gap: 4px; }
    .step-card .header { flex-direction: row; justify-content: space-between; align-items: baseline; }
    .step-card .header .left { font-size: 16px; font-weight: 600; }
    .step-card .header .right { font-size: 16px; font-weight: 600; text-align: right; }
    .transition-card .header .primary { font-size: 14px; font-weight: 600; text-align: center; color: #4b5563; }
    .card-body { margin-top: 4px; border-radius: 10px; padding: 8px 10px; font-family: Consolas, "Courier New", monospace; font-size: 13px; line-height: 1.35; color: #1f2933; }
    .step-card .card-body { background: #edf6fb; white-space: pre-wrap; }
    .transition-card .card-body { background: #f2f3f5; white-space: pre; overflow-x: auto; }
    .transition-stack { display: flex; flex-direction: column; gap: 10px; align-items: center; }

    .hint { font-size: 12px; color: #6b7280; text-align: center; margin-top: 8px; }

    /* Overlay and edges */
    .diagram-overlay { position: absolute; left: 0; top: 0; width: auto; height: auto; pointer-events: none; overflow: visible; }
    .edge { fill: none; stroke-width: 2; opacity: 1; }
    .edge.step-to-tr { stroke: #9aa3af; }
    .edge.tr-to-step { stroke: #9aa3af; }
    .edge.tr-to-jump { stroke: #9aa3af; }
    .jump-label { font: 12px/1.2 "Segoe UI", Arial, sans-serif; fill: #1f2933; cursor: pointer; }
    .jump-label-bg { fill: #edf6fb; stroke: #9ac6dd; stroke-width: 1; rx: 4; ry: 4; }
  </style>
</head>
<body>
  <main>
    <h1>Untitled</h1>
    <div class="diagram">
      <div class="diagram-content">
        <div class="cell" style="grid-column: 1; grid-row: 1;"><div class="step-card" id="step-1-r1" data-step-no="1" data-row="1" data-col="1">
  <div class="header">
    <div class="left">Init</div>
    <div class="right">S1</div>
  </div>
</div></div><div class="cell" style="grid-column: 1; grid-row: 2;"><div class="transition-stack">
<div class="transition-card" id="tr-1-r2-c1" data-tr-no="1" data-row="2" data-col="1" data-from-steps="1" data-direct-to-steps="" data-jumps="">
  <div class="card-body"><svg xmlns="http://www.w3.org/2000/svg" width="117" height="22" viewBox="0 0 117 22"><text x="6" y="16" font-family="Consolas, Courier New, monospace" font-size="12">LiteralConstant</text></svg></div>
  <div class="header">
    <div class="primary">Init state (T1)</div>
  </div>
</div>
</div></div>
      </div>
      <svg class="diagram-overlay" id="diagram-overlay" width="0" height="0" viewBox="0 0 0 0">
        <defs>
          <marker id="arrow" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
            <path d="M 0 0 L 10 5 L 0 10 z" fill="#9aa3af"></path>
          </marker>
        </defs>
        <g id="edges-layer"></g>
        <g id="labels-layer"></g>
      </svg>
    </div>
  </main>
  <script>
    (function() {
      const diagram = document.querySelector('.diagram');
      const overlay = document.getElementById('diagram-overlay');
      const edgesLayer = document.getElementById('edges-layer');
      const labelsLayer = document.getElementById('labels-layer');
      const content = document.querySelector('.diagram-content');

      // Horizontal offset (in px) from a step when drawing orthogonal edges.
      // Used for: step->transition (near source step) and transition->step (near target step)
      const EDGE_HORIZONTAL_OFFSET = 20;

      function setOverlaySize() {
        if (!diagram || !overlay) return;
        const w = content ? content.scrollWidth : diagram.scrollWidth;
        const h = content ? content.scrollHeight : diagram.scrollHeight;
        overlay.setAttribute('width', String(w));
        overlay.setAttribute('height', String(h));
        overlay.setAttribute('viewBox', `0 0 ${w} ${h}`);
      }

      function relRect(el) {
        const dRect = diagram.getBoundingClientRect();
        const r = el.getBoundingClientRect();
        // coordinates relative to the diagram (overlay origin)
        const x = r.left - dRect.left;
        const y = r.top - dRect.top;
        return { x, y, w: r.width, h: r.height };
      }

      function storePositions() {
        const all = diagram.querySelectorAll('.step-card, .transition-card');
        all.forEach(el => {
          const { x, y, w, h } = relRect(el);
          el.dataset.absX = String(Math.round(x));
          el.dataset.absY = String(Math.round(y));
          el.dataset.absW = String(Math.round(w));
          el.dataset.absH = String(Math.round(h));
        });
      }

      function clearEdges() {
        while (edgesLayer.firstChild) edgesLayer.removeChild(edgesLayer.firstChild);
        while (labelsLayer.firstChild) labelsLayer.removeChild(labelsLayer.firstChild);
      }

      function pathCubic(x1, y1, x2, y2) {
        const X1 = Math.round(x1), Y1 = Math.round(y1);
        const X2 = Math.round(x2), Y2 = Math.round(y2);
        const dy = Math.abs(Y2 - Y1);
        const k = Math.max(20, Math.round(dy * 0.3));
        const c1x = X1, c1y = Y1 + k;
        const c2x = X2, c2y = Y2 - k;
        return `M ${X1} ${Y1} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${X2} ${Y2}`;
      }

      function pathOrthogonal(x1, y1, x2, y2, positionMode, offsetPx) {
        // positionMode: 'source' => horizontal near source step
        //               'target' => horizontal near target step
        const X1 = Math.round(x1), Y1 = Math.round(y1);
        const X2 = Math.round(x2), Y2 = Math.round(y2);
        const dy = Y2 - Y1;
        const sign = dy >= 0 ? 1 : -1;
        const off = Math.max(4, Number(offsetPx || 0));
        let yMid;
        if (positionMode === 'source') {
          yMid = Y1 + sign * off;
        } else {
          // default to 'target'
          yMid = Y2 - sign * off;
        }
        const YM = Math.round(yMid);
        return `M ${X1} ${Y1} L ${X1} ${YM} L ${X2} ${YM} L ${X2} ${Y2}`;
      }

      function addEdge(x1, y1, x2, y2, cls) {
        const p = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        p.setAttribute('class', `edge ${cls}`);
        let d;
        if (cls === 'step-to-tr') {
          // Horizontal segment near the source step (AltBegin)
          let X1 = Math.round(x1), Y1 = Math.round(y1);
          let X2 = Math.round(x2), Y2 = Math.round(y2);
          const dx = Math.abs(X2 - X1);
          if (dx <= 6) {
            // force exact vertical alignment to avoid crooked look
            X2 = X1;
          }
          d = Math.abs(X2 - X1) > 6
            ? pathOrthogonal(X1, Y1, X2, Y2, 'source', EDGE_HORIZONTAL_OFFSET)
            : `M ${X1} ${Y1} L ${X1} ${Y2}`;
        } else if (cls === 'tr-to-step') {
          // Horizontal segment near the target step (AltEnd)
          // Using the target-based offset ensures merging lines align horizontally.
          let X1 = Math.round(x1), Y1 = Math.round(y1);
          let X2 = Math.round(x2), Y2 = Math.round(y2);
          const dx = Math.abs(X2 - X1);
          if (dx <= 6) {
            // force exact vertical alignment
            X2 = X1;
          }
          d = Math.abs(X2 - X1) > 6
            ? pathOrthogonal(X1, Y1, X2, Y2, 'target', EDGE_HORIZONTAL_OFFSET)
            : `M ${X1} ${Y1} L ${X1} ${Y2}`;
        } else {
          // For jump labels and other edges, keep previous behavior
          let X1 = Math.round(x1), Y1 = Math.round(y1);
          let X2 = Math.round(x2), Y2 = Math.round(y2);
          const dx = Math.abs(X2 - X1);
          d = dx > 6
            ? pathOrthogonal(X1, Y1, X2, Y2, 'target', 12)
            : pathCubic(X1, Y1, X2, Y2);
        }
        p.setAttribute('d', d);
        if (cls !== 'step-to-tr') {
          p.setAttribute('marker-end', 'url(#arrow)');
        }
        edgesLayer.appendChild(p);
      }

      function drawEdges() {
        const steps = Array.from(diagram.querySelectorAll('.step-card'));
        const trs = Array.from(diagram.querySelectorAll('.transition-card'));

        // Step -> following transitions
        steps.forEach(step => {
          const sr = Number(step.dataset.row || 0);
          const sc = Number(step.dataset.col || 1);
          const sx = Number(step.dataset.absX || 0);
          const sy = Number(step.dataset.absY || 0);
          const sw = Number(step.dataset.absW || 0);
          const sh = Number(step.dataset.absH || 0);

          const nextRow = sr + 1;
          const candidates = trs.filter(t => Number(t.dataset.row || 0) === nextRow);
          // Only draw edges to transitions that list this step as a direct upstream
          const targets = candidates.filter(t => {
            const fromList = (t.dataset.fromSteps || '').split(',').map(s => s.trim()).filter(Boolean);
            return fromList.includes(String(step.dataset.stepNo));
          });
          targets.forEach(t => {
            const tx = Number(t.dataset.absX || 0);
            const ty = Number(t.dataset.absY || 0);
            const tw = Number(t.dataset.absW || 0);
            const startX = sx + sw / 2;
            const startY = sy + sh;
            const endX = tx + tw / 2;
            const endY = ty;
            addEdge(startX, startY, endX, endY, 'step-to-tr');
          });
        });

        // Transition -> direct target steps (excluding jumps)
        trs.forEach(tr => {
          const trX = Number(tr.dataset.absX || 0);
          const trY = Number(tr.dataset.absY || 0);
          const trW = Number(tr.dataset.absW || 0);
          const trH = Number(tr.dataset.absH || 0);
          const list = (tr.dataset.directToSteps || '').split(',').map(s => s.trim()).filter(Boolean);
          if (!list.length) return;
          list.forEach(stepNo => {
            const target = diagram.querySelector(`.step-card[data-step-no="${stepNo}"]`);
            if (!target) return;
            const sx = Number(target.dataset.absX || 0);
            const sy = Number(target.dataset.absY || 0);
            const sw = Number(target.dataset.absW || 0);
            const startX = trX + trW / 2;
            const startY = trY + trH;
            const endX = sx + sw / 2;
            const endY = sy;
            addEdge(startX, startY, endX, endY, 'tr-to-step');
          });
        });

        // Transition -> jump labels (render as overlay labels; clicking focuses target step)
        trs.forEach(tr => {
          const trX = Number(tr.dataset.absX || 0);
          const trY = Number(tr.dataset.absY || 0);
          const trW = Number(tr.dataset.absW || 0);
          const trH = Number(tr.dataset.absH || 0);
          const raw = tr.dataset.jumps || '';
          if (!raw) return;
          let jumps = [];
          try { jumps = JSON.parse(raw); } catch {}
          jumps.forEach((j, idx) => {
            const stepNo = j && j.no != null ? String(j.no) : '';
            const stepName = (j && j.name) ? String(j.name) : '';
            if (!stepNo) return;
            const target = diagram.querySelector(`.step-card[data-step-no="${stepNo}"]`);
            if (!target) return;
            const startX = trX + trW / 2;
            const startY = trY + trH;

            // Label position: centered below transition card, stack if multiple
            const labelText = `S${stepNo}: ${stepName}`;
            const labelX = trX + trW / 2;
            const labelY = trY + trH + (10 * 4) + (idx * (18 * 4));

            // Create clickable label (background rect + text)
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('class', 'jump-label');
            const txt = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            txt.textContent = labelText;
            txt.setAttribute('x', String(labelX));
            txt.setAttribute('y', String(labelY));
            txt.setAttribute('text-anchor', 'middle');

            // measure text by temporary append
            labelsLayer.appendChild(txt);
            const bb = txt.getBBox();
            labelsLayer.removeChild(txt);

            const paddingX = 6, paddingY = 3;
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('class', 'jump-label-bg');
            rect.setAttribute('x', String(bb.x - paddingX));
            rect.setAttribute('y', String(bb.y - paddingY));
            rect.setAttribute('width', String(bb.width + 2 * paddingX));
            rect.setAttribute('height', String(bb.height + 2 * paddingY));

            // Draw connector ending at the top edge of the label so arrow is visible
            const endY = (bb.y - paddingY) - 2;
            addEdge(startX, startY, labelX, endY, 'tr-to-jump');

            // group and interactivity
            g.appendChild(rect);
            g.appendChild(txt);
            g.style.pointerEvents = 'auto';
            g.addEventListener('click', () => {
              const targetEl = diagram.querySelector(`.step-card[data-step-no="${stepNo}"]`);
              if (!targetEl) return;
              targetEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
              // flash outline
              targetEl.style.transition = 'box-shadow 0.2s';
              const prev = targetEl.style.boxShadow;
              targetEl.style.boxShadow = '0 0 0 3px #f59e0b inset';
              setTimeout(() => { targetEl.style.boxShadow = prev; }, 900);
            });
            labelsLayer.appendChild(g);
          });
        });
      }

      let rafId = 0;
      function schedule() {
        if (rafId) cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(() => {
          setOverlaySize();
          storePositions();
          clearEdges();
          drawEdges();
        });
      }

      window.addEventListener('resize', schedule);
      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        schedule();
      } else {
        window.addEventListener('DOMContentLoaded', schedule);
      }
      // Recompute after fonts settle
      window.setTimeout(schedule, 300);
    })();
  </script>
</body>
</html>

