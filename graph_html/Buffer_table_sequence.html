<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Untitled</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: light dark; }
    body { margin: 0; font-family: "Segoe UI", Arial, sans-serif; background: #f5f7fa; color: #1f2933; }
    main { padding: 32px; box-sizing: border-box; }
    h1 { margin: 0 0 24px; font-size: 24px; font-weight: 600; }

    .diagram { position: relative; overflow: visible; }
    .diagram-content { display: grid; gap: 20px 16px; align-items: start; padding-bottom: 160px; width: max-content; }
    .cell { min-height: 8px; display: flex; justify-content: center; }

    .step-card, .transition-card { display: flex; flex-direction: column; gap: 8px; box-sizing: border-box; background: #ffffff; border: 1px solid #d2d6dc; box-shadow: 0 10px 30px rgba(31, 41, 51, 0.08); padding: 14px 16px; min-width: 220px; }
    .step-card { border-color: #9ac6dd; border-radius: 0; width: 100%; }
    .transition-card { border: 1px solid #9aa3af; background: #f7f8fa; border-radius: 16px; width: max-content; margin-left: 12px; margin-right: 12px; box-shadow: none; padding: 8px 16px; }
    .step-card .header, .transition-card .header { display: flex; flex-direction: column; gap: 4px; }
    .step-card .header { flex-direction: row; justify-content: space-between; align-items: baseline; }
    .step-card .header .left { font-size: 16px; font-weight: 600; }
    .step-card .header .right { font-size: 16px; font-weight: 600; text-align: right; }
    .transition-card .header .primary { font-size: 14px; font-weight: 600; text-align: center; color: #4b5563; }
    .card-body { margin-top: 4px; border-radius: 10px; padding: 8px 10px; font-family: Consolas, "Courier New", monospace; font-size: 13px; line-height: 1.35; color: #1f2933; }
    .step-card .card-body { background: #edf6fb; white-space: pre-wrap; }
    .transition-card .card-body { background: #f2f3f5; white-space: pre; overflow-x: auto; }
    .transition-stack { display: flex; flex-direction: column; gap: 10px; align-items: center; }

    .hint { font-size: 12px; color: #6b7280; text-align: center; margin-top: 8px; }

    /* Overlay and edges */
    .diagram-overlay { position: absolute; left: 0; top: 0; width: auto; height: auto; pointer-events: none; overflow: visible; }
    .edge { fill: none; stroke-width: 2; opacity: 1; }
    .edge.step-to-tr { stroke: #9aa3af; }
    .edge.tr-to-step { stroke: #9aa3af; }
    .edge.tr-to-jump { stroke: #9aa3af; }
    .jump-label { font: 12px/1.2 "Segoe UI", Arial, sans-serif; fill: #1f2933; cursor: pointer; }
    .jump-label-bg { fill: #edf6fb; stroke: #9ac6dd; stroke-width: 1; rx: 4; ry: 4; }
  </style>
</head>
<body>
  <main>
    <h1>Untitled</h1>
    <div class="diagram">
      <div class="diagram-content">
        <div class="cell" style="grid-column: 1; grid-row: 1;"><div class="step-card" id="step-1-r1" data-step-no="1" data-row="1" data-col="1">
  <div class="header">
    <div class="left">Wait for start</div>
    <div class="right">S1</div>
  </div>
  <div class="card-body">N: #Ready_to_stop
R: #Clearing_done
</div>
</div></div><div class="cell" style="grid-column: 1; grid-row: 2;"><div class="transition-stack" style="margin-top: 16px;">
<div class="transition-card" id="tr-1-r2-c1" data-tr-no="1" data-row="2" data-col="1" data-from-steps="1" data-direct-to-steps="2" data-jumps="">
  <div class="card-body"><svg xmlns="http://www.w3.org/2000/svg" width="188" height="40" viewBox="0 0 188 40"><rect x="6" y="7" width="24" height="28" rx="0" ry="0" fill="#f0f1f3" stroke="#374151" stroke-width="1" shape-rendering="crispEdges" /><text x="18" y="25" text-anchor="middle" font-family="Segoe UI, Arial" font-size="12" fill="#374151">&amp;</text><text x="42" y="16" font-family="Consolas, Courier New, monospace" font-size="12">Auto_active</text><line x1="30" y1="12" x2="37" y2="12" stroke="#374151" stroke-width="1" shape-rendering="crispEdges" /><text x="42" y="34" font-family="Consolas, Courier New, monospace" font-size="12">NOT Clearing_station</text><line x1="30" y1="30" x2="37" y2="30" stroke="#374151" stroke-width="1" shape-rendering="crispEdges" /></svg></div>
  <div class="header">
    <div class="primary">Auto active (T1)</div>
  </div>
</div>
</div></div><div class="cell" style="grid-column: 2; grid-row: 2;"><div class="transition-stack" style="margin-top: 16px;">
<div class="transition-card" id="tr-9-r2-c2" data-tr-no="9" data-row="2" data-col="2" data-from-steps="1" data-direct-to-steps="5" data-jumps="">
  <div class="card-body"><svg xmlns="http://www.w3.org/2000/svg" width="160" height="40" viewBox="0 0 160 40"><rect x="6" y="7" width="24" height="28" rx="0" ry="0" fill="#f0f1f3" stroke="#374151" stroke-width="1" shape-rendering="crispEdges" /><text x="18" y="25" text-anchor="middle" font-family="Segoe UI, Arial" font-size="12" fill="#374151">&amp;</text><text x="42" y="16" font-family="Consolas, Courier New, monospace" font-size="12">Auto_active</text><line x1="30" y1="12" x2="37" y2="12" stroke="#374151" stroke-width="1" shape-rendering="crispEdges" /><text x="42" y="34" font-family="Consolas, Courier New, monospace" font-size="12">Clearing_station</text><line x1="30" y1="30" x2="37" y2="30" stroke="#374151" stroke-width="1" shape-rendering="crispEdges" /></svg></div>
  <div class="header">
    <div class="primary">Clearing station (T9)</div>
  </div>
</div>
</div></div><div class="cell" style="grid-column: 1; grid-row: 3;"><div class="step-card" id="step-2-r3" data-step-no="2" data-row="3" data-col="1">
  <div class="header">
    <div class="left">Wait for request</div>
    <div class="right">S2</div>
  </div>
  <div class="card-body">N: #Ready_to_stop
</div>
</div></div><div class="cell" style="grid-column: 1; grid-row: 4;"><div class="transition-stack">
<div class="transition-card" id="tr-2-r4-c1" data-tr-no="2" data-row="4" data-col="1" data-from-steps="2" data-direct-to-steps="9" data-jumps="">
  <div class="card-body"><svg xmlns="http://www.w3.org/2000/svg" width="300" height="58" viewBox="0 0 300 58"><rect x="6" y="7" width="24" height="46" rx="0" ry="0" fill="#f0f1f3" stroke="#374151" stroke-width="1" shape-rendering="crispEdges" /><text x="18" y="34" text-anchor="middle" font-family="Segoe UI, Arial" font-size="12" fill="#374151">&amp;</text><text x="42" y="16" font-family="Consolas, Courier New, monospace" font-size="12">Collector.Request_cores</text><line x1="30" y1="12" x2="37" y2="12" stroke="#374151" stroke-width="1" shape-rendering="crispEdges" /><text x="42" y="34" font-family="Consolas, Courier New, monospace" font-size="12">Collector.Req_core_type == Core_code</text><line x1="30" y1="30" x2="37" y2="30" stroke="#374151" stroke-width="1" shape-rendering="crispEdges" /><text x="42" y="52" font-family="Consolas, Courier New, monospace" font-size="12">Feeder_ready</text><line x1="30" y1="48" x2="37" y2="48" stroke="#374151" stroke-width="1" shape-rendering="crispEdges" /></svg></div>
  <div class="header">
    <div class="primary">Matching core code requested (T2)</div>
  </div>
</div>
</div></div><div class="cell" style="grid-column: 1; grid-row: 5;"><div class="step-card" id="step-9-r5" data-step-no="9" data-row="5" data-col="1">
  <div class="header">
    <div class="left">Acknowledge request</div>
    <div class="right">S9</div>
  </div>
  <div class="card-body">N: #Request_order_num := #Collector.Req_order_num
N: #Request_core_count := #Collector.Req_core_count
N: #Collector.Req_processed
</div>
</div></div><div class="cell" style="grid-column: 1; grid-row: 6;"><div class="transition-stack">
<div class="transition-card" id="tr-10-r6-c1" data-tr-no="10" data-row="6" data-col="1" data-from-steps="9" data-direct-to-steps="3" data-jumps="">
  <div class="card-body"><svg xmlns="http://www.w3.org/2000/svg" width="229" height="22" viewBox="0 0 229 22"><text x="6" y="16" font-family="Consolas, Courier New, monospace" font-size="12">Acknowledge request.T &gt; t#500MS</text></svg></div>
  <div class="header">
    <div class="primary">Acknowledge pulse time (T10)</div>
  </div>
</div>
</div></div><div class="cell" style="grid-column: 1; grid-row: 7;"><div class="step-card" id="step-3-r7" data-step-no="3" data-row="7" data-col="1">
  <div class="header">
    <div class="left">Feed cores to chute</div>
    <div class="right">S3</div>
  </div>
  <div class="card-body">N: #Feed_request
</div>
</div></div><div class="cell" style="grid-column: 1; grid-row: 8;"><div class="transition-stack">
<div class="transition-card" id="tr-3-r8-c1" data-tr-no="3" data-row="8" data-col="1" data-from-steps="3" data-direct-to-steps="4" data-jumps="">
  <div class="card-body"><svg xmlns="http://www.w3.org/2000/svg" width="89" height="22" viewBox="0 0 89 22"><text x="6" y="16" font-family="Consolas, Courier New, monospace" font-size="12">Feeder_done</text></svg></div>
  <div class="header">
    <div class="primary">Cores feeded to chute (T3)</div>
  </div>
</div>
</div></div><div class="cell" style="grid-column: 1; grid-row: 9;"><div class="step-card" id="step-4-r9" data-step-no="4" data-row="9" data-col="1">
  <div class="header">
    <div class="left">Wait for delivery order</div>
    <div class="right">S4</div>
  </div>
  <div class="card-body">N: #Ready_to_stop
</div>
</div></div><div class="cell" style="grid-column: 1; grid-row: 10;"><div class="transition-stack">
<div class="transition-card" id="tr-4-r10-c1" data-tr-no="4" data-row="10" data-col="1" data-from-steps="4" data-direct-to-steps="5" data-jumps="">
  <div class="card-body"><svg xmlns="http://www.w3.org/2000/svg" width="383" height="22" viewBox="0 0 383 22"><text x="6" y="16" font-family="Consolas, Courier New, monospace" font-size="12">Collector.Ready_to_receive_order == Request_order_num</text></svg></div>
  <div class="header">
    <div class="primary">Collector ready to receive this order num (T4)</div>
  </div>
</div>
</div></div>
      </div>
      <svg class="diagram-overlay" id="diagram-overlay" width="0" height="0" viewBox="0 0 0 0">
        <defs>
          <marker id="arrow" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
            <path d="M 0 0 L 10 5 L 0 10 z" fill="#9aa3af"></path>
          </marker>
        </defs>
        <g id="edges-layer"></g>
        <g id="labels-layer"></g>
      </svg>
    </div>
  </main>
  <script>
    (function() {
      const diagram = document.querySelector('.diagram');
      const overlay = document.getElementById('diagram-overlay');
      const edgesLayer = document.getElementById('edges-layer');
      const labelsLayer = document.getElementById('labels-layer');
      const content = document.querySelector('.diagram-content');

      // Horizontal offset (in px) from a step when drawing orthogonal edges.
      // Used for: step->transition (near source step) and transition->step (near target step)
      const EDGE_HORIZONTAL_OFFSET = 20;

      function setOverlaySize() {
        if (!diagram || !overlay) return;
        const w = content ? content.scrollWidth : diagram.scrollWidth;
        const h = content ? content.scrollHeight : diagram.scrollHeight;
        overlay.setAttribute('width', String(w));
        overlay.setAttribute('height', String(h));
        overlay.setAttribute('viewBox', `0 0 ${w} ${h}`);
      }

      function relRect(el) {
        const dRect = diagram.getBoundingClientRect();
        const r = el.getBoundingClientRect();
        // coordinates relative to the diagram (overlay origin)
        const x = r.left - dRect.left;
        const y = r.top - dRect.top;
        return { x, y, w: r.width, h: r.height };
      }

      function storePositions() {
        const all = diagram.querySelectorAll('.step-card, .transition-card');
        all.forEach(el => {
          const { x, y, w, h } = relRect(el);
          el.dataset.absX = String(Math.round(x));
          el.dataset.absY = String(Math.round(y));
          el.dataset.absW = String(Math.round(w));
          el.dataset.absH = String(Math.round(h));
        });
      }

      function clearEdges() {
        while (edgesLayer.firstChild) edgesLayer.removeChild(edgesLayer.firstChild);
        while (labelsLayer.firstChild) labelsLayer.removeChild(labelsLayer.firstChild);
      }

      function pathCubic(x1, y1, x2, y2) {
        const X1 = Math.round(x1), Y1 = Math.round(y1);
        const X2 = Math.round(x2), Y2 = Math.round(y2);
        const dy = Math.abs(Y2 - Y1);
        const k = Math.max(20, Math.round(dy * 0.3));
        const c1x = X1, c1y = Y1 + k;
        const c2x = X2, c2y = Y2 - k;
        return `M ${X1} ${Y1} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${X2} ${Y2}`;
      }

      function pathOrthogonal(x1, y1, x2, y2, positionMode, offsetPx) {
        // positionMode: 'source' => horizontal near source step
        //               'target' => horizontal near target step
        const X1 = Math.round(x1), Y1 = Math.round(y1);
        const X2 = Math.round(x2), Y2 = Math.round(y2);
        const dy = Y2 - Y1;
        const sign = dy >= 0 ? 1 : -1;
        const off = Math.max(4, Number(offsetPx || 0));
        let yMid;
        if (positionMode === 'source') {
          yMid = Y1 + sign * off;
        } else {
          // default to 'target'
          yMid = Y2 - sign * off;
        }
        const YM = Math.round(yMid);
        return `M ${X1} ${Y1} L ${X1} ${YM} L ${X2} ${YM} L ${X2} ${Y2}`;
      }

      function addEdge(x1, y1, x2, y2, cls) {
        const p = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        p.setAttribute('class', `edge ${cls}`);
        let d;
        if (cls === 'step-to-tr') {
          // Horizontal segment near the source step (AltBegin)
          let X1 = Math.round(x1), Y1 = Math.round(y1);
          let X2 = Math.round(x2), Y2 = Math.round(y2);
          const dx = Math.abs(X2 - X1);
          if (dx <= 6) {
            // force exact vertical alignment to avoid crooked look
            X2 = X1;
          }
          d = Math.abs(X2 - X1) > 6
            ? pathOrthogonal(X1, Y1, X2, Y2, 'source', EDGE_HORIZONTAL_OFFSET)
            : `M ${X1} ${Y1} L ${X1} ${Y2}`;
        } else if (cls === 'tr-to-step') {
          // Horizontal segment near the target step (AltEnd)
          // Using the target-based offset ensures merging lines align horizontally.
          let X1 = Math.round(x1), Y1 = Math.round(y1);
          let X2 = Math.round(x2), Y2 = Math.round(y2);
          const dx = Math.abs(X2 - X1);
          if (dx <= 6) {
            // force exact vertical alignment
            X2 = X1;
          }
          d = Math.abs(X2 - X1) > 6
            ? pathOrthogonal(X1, Y1, X2, Y2, 'target', EDGE_HORIZONTAL_OFFSET)
            : `M ${X1} ${Y1} L ${X1} ${Y2}`;
        } else {
          // For jump labels and other edges, keep previous behavior
          let X1 = Math.round(x1), Y1 = Math.round(y1);
          let X2 = Math.round(x2), Y2 = Math.round(y2);
          const dx = Math.abs(X2 - X1);
          d = dx > 6
            ? pathOrthogonal(X1, Y1, X2, Y2, 'target', 12)
            : pathCubic(X1, Y1, X2, Y2);
        }
        p.setAttribute('d', d);
        if (cls !== 'step-to-tr') {
          p.setAttribute('marker-end', 'url(#arrow)');
        }
        edgesLayer.appendChild(p);
      }

      function drawEdges() {
        const steps = Array.from(diagram.querySelectorAll('.step-card'));
        const trs = Array.from(diagram.querySelectorAll('.transition-card'));

        // Step -> following transitions
        steps.forEach(step => {
          const sr = Number(step.dataset.row || 0);
          const sc = Number(step.dataset.col || 1);
          const sx = Number(step.dataset.absX || 0);
          const sy = Number(step.dataset.absY || 0);
          const sw = Number(step.dataset.absW || 0);
          const sh = Number(step.dataset.absH || 0);

          const nextRow = sr + 1;
          const candidates = trs.filter(t => Number(t.dataset.row || 0) === nextRow);
          // Only draw edges to transitions that list this step as a direct upstream
          const targets = candidates.filter(t => {
            const fromList = (t.dataset.fromSteps || '').split(',').map(s => s.trim()).filter(Boolean);
            return fromList.includes(String(step.dataset.stepNo));
          });
          targets.forEach(t => {
            const tx = Number(t.dataset.absX || 0);
            const ty = Number(t.dataset.absY || 0);
            const tw = Number(t.dataset.absW || 0);
            const startX = sx + sw / 2;
            const startY = sy + sh;
            const endX = tx + tw / 2;
            const endY = ty;
            addEdge(startX, startY, endX, endY, 'step-to-tr');
          });
        });

        // Transition -> direct target steps (excluding jumps)
        trs.forEach(tr => {
          const trX = Number(tr.dataset.absX || 0);
          const trY = Number(tr.dataset.absY || 0);
          const trW = Number(tr.dataset.absW || 0);
          const trH = Number(tr.dataset.absH || 0);
          const list = (tr.dataset.directToSteps || '').split(',').map(s => s.trim()).filter(Boolean);
          if (!list.length) return;
          list.forEach(stepNo => {
            const target = diagram.querySelector(`.step-card[data-step-no="${stepNo}"]`);
            if (!target) return;
            const sx = Number(target.dataset.absX || 0);
            const sy = Number(target.dataset.absY || 0);
            const sw = Number(target.dataset.absW || 0);
            const startX = trX + trW / 2;
            const startY = trY + trH;
            const endX = sx + sw / 2;
            const endY = sy;
            addEdge(startX, startY, endX, endY, 'tr-to-step');
          });
        });

        // Transition -> jump labels (render as overlay labels; clicking focuses target step)
        trs.forEach(tr => {
          const trX = Number(tr.dataset.absX || 0);
          const trY = Number(tr.dataset.absY || 0);
          const trW = Number(tr.dataset.absW || 0);
          const trH = Number(tr.dataset.absH || 0);
          const raw = tr.dataset.jumps || '';
          if (!raw) return;
          let jumps = [];
          try { jumps = JSON.parse(raw); } catch {}
          jumps.forEach((j, idx) => {
            const stepNo = j && j.no != null ? String(j.no) : '';
            const stepName = (j && j.name) ? String(j.name) : '';
            if (!stepNo) return;
            const target = diagram.querySelector(`.step-card[data-step-no="${stepNo}"]`);
            if (!target) return;
            const startX = trX + trW / 2;
            const startY = trY + trH;

            // Label position: centered below transition card, stack if multiple
            const labelText = `S${stepNo}: ${stepName}`;
            const labelX = trX + trW / 2;
            const labelY = trY + trH + (10 * 4) + (idx * (18 * 4));

            // Create clickable label (background rect + text)
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('class', 'jump-label');
            const txt = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            txt.textContent = labelText;
            txt.setAttribute('x', String(labelX));
            txt.setAttribute('y', String(labelY));
            txt.setAttribute('text-anchor', 'middle');

            // measure text by temporary append
            labelsLayer.appendChild(txt);
            const bb = txt.getBBox();
            labelsLayer.removeChild(txt);

            const paddingX = 6, paddingY = 3;
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('class', 'jump-label-bg');
            rect.setAttribute('x', String(bb.x - paddingX));
            rect.setAttribute('y', String(bb.y - paddingY));
            rect.setAttribute('width', String(bb.width + 2 * paddingX));
            rect.setAttribute('height', String(bb.height + 2 * paddingY));

            // Draw connector ending at the top edge of the label so arrow is visible
            const endY = (bb.y - paddingY) - 2;
            addEdge(startX, startY, labelX, endY, 'tr-to-jump');

            // group and interactivity
            g.appendChild(rect);
            g.appendChild(txt);
            g.style.pointerEvents = 'auto';
            g.addEventListener('click', () => {
              const targetEl = diagram.querySelector(`.step-card[data-step-no="${stepNo}"]`);
              if (!targetEl) return;
              targetEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
              // flash outline
              targetEl.style.transition = 'box-shadow 0.2s';
              const prev = targetEl.style.boxShadow;
              targetEl.style.boxShadow = '0 0 0 3px #f59e0b inset';
              setTimeout(() => { targetEl.style.boxShadow = prev; }, 900);
            });
            labelsLayer.appendChild(g);
          });
        });
      }

      let rafId = 0;
      function schedule() {
        if (rafId) cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(() => {
          setOverlaySize();
          storePositions();
          clearEdges();
          drawEdges();
        });
      }

      window.addEventListener('resize', schedule);
      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        schedule();
      } else {
        window.addEventListener('DOMContentLoaded', schedule);
      }
      // Recompute after fonts settle
      window.setTimeout(schedule, 300);
    })();
  </script>
</body>
</html>

